#+TITLE: My Literate =.emacs.d=
#+AUTHOR: Robb Enzmann
#+PROPERTY: header-args:emacs-lisp :tangle init.el :results none :eval never-export :comments link
#+OPTIONS: toc:1 num:nil
#+STARTUP: overview indent

Want to use it? Go ahead!

#+begin_src shell :eval never
  git clone https://github.com/renzmann/.emacs.d ~/.emacs.d
#+end_src

All external dependency sources are explicitly included under the ~elpa/~
directory, meaning it's as simple as "clone-n-go".  Opening this document under
my configuration looks like so:

#+attr_html: :width 800px
[[https://raw.githubusercontent.com/renzmann/.emacs.d/e93d5ea85896745ed5e79fa725278cd37f09f727/img/emacs-screen.png]]

If you prefer a prettier reading experience, check out this same document weaved
into [[https://robbmann.io/emacsd/][my website.]]  Or, if you're already reading this on my website, check out
the [[https://github.com/renzmann/.emacs.d/][source code on GitHub]].

* Goals
If I had to sum up the theme of my configuration, it would be "vanilla extract,"
because in only a few instances do I change the overt behavior of Emacs.  Even
with those, though, I want a configuration that fits my hands in such a way that
I remain comfortable using =emacs -Q= with very little disruption to my normal
muscle memory and workflow.

Aside from these aesthetic and philosophical reasons, there are practical
concerns this configuration needs to address.  I spend my time on Windows for
games, macOS or Linux with remote machines for work, and desktop Linux for
personal projects like building my website.  Some of these situations enforce a
very slow internet connection and tight security measures for Tramp, which can
cause modern, "live updating" features like =corfu= and =consult= to hang Emacs.
In other cases, I have no access to the outside internet at all (so no ELPA or
MELPA updates).  Hence, keeping only a small number of external dependencies
under =elpa/= maximizes portability and maintainability between systems.

Altogether, I wind up using Emacs 29+ on all three of the major platforms, in
both GUI and TTY mode.  So this config is designed to work equally well for:

|----------+----------+-----+-----------+-------|
| platform | terminal | GUI | ssh + TTY | Tramp |
|----------+----------+-----+-----------+-------|
| Linux    | ✅       | ✅  | ✅        | ✅    |
| macOS    | ✅       | ✅  | ✅        | ✅    |
| Windows  | ❌       | ✅  | ❌        | ✅    |
|----------+----------+-----+-----------+-------|

* Notable Features
You may notice that despite the laudable goal of intended minimalism, this
document is is still quite long, as I have found many (ever increasing) quirky
behaviors of Emacs that I tweak.  Most of my time is spent in Org, SQL, Python,
Bash, YAML, TOML, and Markdown, so the majority of configuration lies around
these sections.

I do make changes to things that I feel "should have been included."  Some
examples of this are:

1. Additional major modes for common filetypes like Markdown, CSV, and YAML
2. Error message support for =pyright= in a =*Compilation*= buffer
3. Reasonable indentation behavior for SQL files
4. Updating buffers automatically if their contents change on disk
5. Syntax highlighting for Source blocks in Markdown
6. Handling ANSI color escape codes in shell output, compilation, and VC buffers

* Tangling
My configuration is a single literate programming document, which is tangled
into the standard =init.el= and supporting files.  This is so I can keep track of
all the crazy things I try, and explain them inline with the final code I decide
to include.  Some platforms like GitHub can render this document in a limited
way, but to see all the final configuration values I use you will likely have to
view this document in Emacs itself.

Why use a literate document for my configuration?  Basically, as I added more
comments and reminders about what some line of code was doing, where I got it
from, and why it might be commented out, the prose grew longer than the actual
code, and so a change of medium felt prudent.  In my case, that's the venerable
[[https://orgmode.org/][Org mode]], which comes with Emacs and serves as a way to seamlessly weave
commentary and code together.

* Inspirations
I steal quite a lot from other, more qualified Emacs community contributors,
such as:

- [[https://protesilaos.com/][Protesilaos Stavrou]]
- [[https://panadestein.github.io/emacsd/][Ramón Panadestein]]
- [[https://www.masteringemacs.org/][Mickey Petersen]]
- [[https://github.com/minad][Daniel Mendler]]
- [[https://github.com/oantolin][Omar Antolín Camarena]]
- [[https://www.lucacambiaghi.com/vanilla-emacs/readme.html][Luca's Literate Config]]

* Getting Emacs
For a while I would try to compile Emacs myself, but installing the whole
compilation toolchain hasn't been worth it lately, especially on Windows.
Instead, I've started simply downloading emacs from these sources on each of the
platforms:

** Windows
I go to the [[https://alpha.gnu.org/gnu/emacs/pretest/windows/][pretest FTP]] to get the latest version of Emacs.  Usually not quite
up-to-date with the master branch, but still one version number ahead of the
most recent official release.

** Mac
On macOS, I've had the best luck with [[https://github.com/jimeh/emacs-builds/releases][jimeh's nightly builds]].  These Emacs.app
bundles have no external dependencies, signed with a developer certificate, and
notarized by Apple, so it /just works/.  Even without administrator permissions,
you can drag the bundle to the "Applications" folder under your user home
instead, and Emacs still works beautifully.

In particular, this feature has saved me a lot of headaches that I ran into
compiling Emacs on my own:

#+begin_quote
Emacs.app is signed with a developer certificate and notarized by Apple.
#+end_quote

Very nice!

** Linux
Depending on the machine, I get Emacs one of several ways in a GNU/Linux setup.
These rank from highest to lowest priority:

1. Through my system package manager, such as =sudo apt-get install emacs= or =pacman -S emacs=
2. Through the [[https://ftp.gnu.org/gnu/emacs/][official FTP]]
3. Through the [[https://alpha.gnu.org/gnu/emacs/pretest/windows/emacs-29/][pretest FTP]]
4. Through [[https://github.com/mariusvniekerk/condax][condax]]
5. Compiling it myself

*** Compiling
If I do ever want to compile it myself, these are the options I use, making sure
to export the correct =CC= and =GCC= variables:

#+begin_src shell
  git clone git://git.savannah.gnu.org/emacs.git --branch emacs-29 --depth 1
  export CC=/usr/bin/gcc-10 CXX=/usr/bin/gcc-10
  ./autogen.sh
  ./configure \
    --prefix=/c/emacs-29 \
    --with-native-compilation \
    --with-tree-sitter \
    --with-gnutls \
    --with-jpeg \
    --with-png \
    --with-rsvg \
    --with-tiff \
    --with-wide-int \
    --with-xft \
    --with-xml2 \
    --with-xpm \
    --without-dbus \
    --without-pop
  make --jobs=$(nproc)
  sudo make install
#+end_src

* Header
To comply with the Emacs [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html][conventions for libraries]], the tangled init.el must
have the following header and [[Footer][footer:]]

#+begin_src emacs-lisp :comments no
  ;;; init.el --- Robb's Emacs configuration -*- lexical-binding: t -*-

  ;; Copyright (C) 2022 Robert Enzmann

  ;; Author: Robb Enzmann <robbenzmann@gmail.com>
  ;; Keywords: internal
  ;; URL: https://robbmann.io/

  ;;; Commentary:
  ;; A mostly minimal, reproducible Emacs configuration.  This file is
  ;; automatically tangled from README.org, with header/footer comments on each
  ;; code block that allow for de-tangling the source back to README.org when
  ;; working on this file directly.

  ;;; Code:
#+end_src

* Custom
I prefer having =custom= modify its own file.  This next snippet ensures any
~package-install~ or =custom= edits go to =custom.el=.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file 'noerror))
#+end_src

* Proxy settings
When behind a corporate proxy, we might have to authenticate before we can pull
packages off ELPA.  Emacs only uses the HOST and PORT portions of the
=http_proxy= and =https_proxy= environment variables, so we need to set LOGIN
(user id) and PASSWORD ourselves.

I store the login, port, and host variables in a =proxy.el= file (obviously
outside version control) when I'm on a machine that's behind an http proxy.  We
grab the password interactively when such a file exists.

#+begin_src emacs-lisp
  (defun renz/enable-proxy ()
    (interactive)
    "Turn on HTTP proxy."
    (let ((proxy-file (expand-file-name "proxy.el" user-emacs-directory)))
      (when (file-exists-p proxy-file)
        (load-file proxy-file)
        (setq url-proxy-services
              `(("no_proxy" . "^\\(localhost\\|10.*\\)")
                ("http" . ,(concat renz/proxy-host ":" renz/proxy-port))
                ("https" . ,(concat renz/proxy-host ":" renz/proxy-port))))
        (setq url-http-proxy-basic-auth-storage
              (list
               (list
                (concat renz/proxy-host ":" renz/proxy-port)
                (cons renz/proxy-login
                      (base64-encode-string
                       (concat renz/proxy-login ":" (password-read "Proxy password: "))))))))))
#+end_src

* Packages
The initial cornerstone of every Emacs configuration is a decision on package
management and configuration.  I opt for =use-package= and =package.el=, since both
are built-in to Emacs 29+, which helps maximize stability and portability.

To avoid loading packages twice, [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html][the manual]] recommends disabling
~package-enable-at-startup~ in ~init.el~.

#+begin_src emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "https://melpa.org/packages/") t)
#+end_src

I do not use the =:ensure t= keyword in =use-package= declarations to install
packages, because I cannot always ensure that I have a stable connection to GNU
ELPA (in the case of =package-install-selected-packages=) or the public
=github.com= (for =package-vc-install-selected-packages=).  Instead, I rely on
=M-x package-install= and =M-x package-delete=, and only permit =use-package= to
handle the configuration and loading of packages.  As mentioned in the
introduction, each package's source is explicitly included into version control
of my configuration, so I don't worry too much about pinning package versions in
this file.  When I want to update a package, I use =M-x package-update=, the
=package.el= user interface, or delete the package's source folder and use
=renz/package-sync= (defined below).  Should something go wrong, I roll back to
a previous commit.  So far, this method has been reliable for keeping my
=init.el= (this README), =custom.el=, the =package-selected-packages= variable,
and =elpa/= directory all in sync with one another.

#+begin_src emacs-lisp
  (defun renz/package-sync ()
    "Remove unused sources and install any missing ones."
    (interactive)
    (package-autoremove)
    (package-install-selected-packages)
    (package-vc-install-selected-packages))

  (when (and (cl-notevery 'package-installed-p package-selected-packages)
             (yes-or-no-p "Install VC packages?"))
    (package-vc-install-selected-packages))
#+end_src

There are also a few hand-made packages I keep around in a special
~.emacs.d/site-lisp~ directory.

#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
#+end_src

* OS-specific Configuration
** Microsoft Windows
Windows, funnily enough, has some trouble registering the Windows key as a
usable modifier for Emacs.  In fact, =s-l= will /never/ be an option, since it's
handled at the hardware level.

#+begin_src emacs-lisp
  (defun renz/windowsp ()
    "Are we on Microsoft Windows?"
    (memq system-type '(windows-nt cygwin ms-dos)))
#+end_src

#+begin_src emacs-lisp
  (when (and (renz/windowsp) (executable-find "pwsh"))
    (setq shell-file-name "pwsh"))
#+end_src

There are a few things I set up independent of Emacs.  Namely, =find=, =xargs=,
and =rg=.  While not perfect, =winget= tends to do the trick nowadays.  Usually
this still requires futzing with my PATH manually after installation.

#+begin_src shell
  winget install Git.Git
  winget install BurntSushi.ripgrep.GNU  # A faster `grep`
  winget install GnuWin32.FindUtils
  winget install GnuWin32.Grep
  winget install RubyInstallerTeam.RubyWithDevKit.3.2  # For building my website with Jekyll
  winget install Python.Python.3.11  # I work a lot in python
  winget install sharkdp.fd  # A faster `find`
#+end_src

You can use Emacs without these, but some commands like =M-x grep= or =M-x
project-find-regexp= will not work without making sure the GNU version of =find=
and =grep= (or a suitable replacement) are on your PATH.  I tend not to muck with
PATH inside Emacs if I can help it, and instead launch Emacs from powershell
where things are properly set.  Usually I'll have some things like this in my =$PROFILE=:

#+begin_src powershell :tangle no
  $ENV:Path = "${ENV:ProgramFiles}\Hunspell\bin\;" + $ENV:Path
  $ENV:Path = "${ENV:ProgramFiles(x86)}\GnuWin32\bin\;" + $ENV:Path
  $ENV:Path = "${ENV:ProgramFiles}\Emacs\emacs-29.1\bin\;" + $ENV:Path
  $ENV:PROFILE = $PROFILE
  $ENV:LANG = "en_US"
  $ENV:DICPATH = "$ENV:ProgramFiles\Hunspell\"
#+end_src

The duplicate =$PROFILE= thing is so we can access that file through =C-x C-f
$PROFILE= within Emacs.  Check out the [[*Spellchecking][Spellchecking]] section on the Hunspell
stuff.

For compiling things like tree-sitter grammars, we'll need =cc= installed and on
=PATH=, which unfortunately still requires a detour through =MINGW64=.

#+begin_src powershell :tangle no
  winget install MSYS2.MSYS2
#+end_src

Then, we open up the MINGW64 command prompt, and use =pacman= to get the
standard toolchain.

#+begin_src shell :tangle no
  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
#+end_src

*** On the winkey

For a time I considered enabling the use of the winkey like this:

#+begin_src emacs-lisp :tangle no :eval never
(setq w32-pass-lwindow-to-system nil)
(setq w32-lwindow-modifier 'super) ; Left Windows key
(setq w32-pass-rwindow-to-system nil)
(setq w32-rwindow-modifier 'super) ; Right Windows key
#+end_src

Followed by enabling specific chords, such as "winkey+a":

#+begin_src emacs-lisp :tangle no :eval never
(w32-register-hot-key [s-a])
#+end_src

Since I've taken a more TTY-friendly approach for my config in general, where
super can be a bit tough to integrate with both the windowing application /and/
the terminal emulator, I've mostly given up on the GUI key in favor of other
chords, especially the =C-c= ones.

** macOS
Launching Emacs from the typical application launcher or command-space usually
won't capture any modifications to =$PATH=, typically handled in a file like
=~/.profile= or =~/.bashrc=. So, the main configuration included here is from
[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]].

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq exec-path-from-shell-arguments '("-l"))
    (exec-path-from-shell-initialize))
#+end_src

* Font
Fonts are a tricky business.  See Emacs/Fonts in the manual (=C-h i=) for relevant
information on how checking and setting default fonts works:

+ [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html][Searching for installed fonts]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html][Setting the default font]]

#+begin_src emacs-lisp
  (cond ((x-list-fonts "Hack Nerd Font")
         (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
        ;; ((x-list-fonts "Segoe UI Emoji")
        ;;  (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
        )

  (defun renz/change-font-size (new-size)
    "Change the default font size to the given size."
    (interactive "nNew font size: ")
    (set-face-attribute 'default nil :height (* 10 new-size)))
#+end_src

* Theme

With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
need for any external themes now.  It is accessible, well optimized for
=org-mode= and =prog-mode=, and distributed with vanilla Emacs.  Hats off to
[[https://protesilaos.com/][Prot]] for these wonderful themes.

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (modus-themes-inhibit-reload nil)
    (modus-themes-subtle-line-numbers t)
    (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
    (modus-themes-diffs 'desaturated)
    (modus-themes-hl-line 'intense)
    (modus-themes-deuteranopia nil)
    (modus-themes-bold-constructs t)
    (modus-themes-italic-constructs t)
    (modus-themes-mode-line 'borderless)
    (modus-themes-org-blocks 'gray-background)
    :bind   ("<f5>" . modus-themes-toggle)
    :config
    (load-theme 'modus-vivendi-tinted t))
#+end_src

* Emacs' Built-in Settings
My settings for base Emacs behavior.  Assuming I ran with /no/ plugins (ala ~emacs
-Q~), I would still set most of these by hand at one point or another.  This
section is designed for variables that modify Emacs and its editing behavior
directly.  Configuation for built-in tools, such as Dired, Tramp, and
Tree-sitter are located under [[* Tool configuration][Tool configuration]].

** Stop stupid bell
This snippet has a special place in my heart, because it was the first two lines
of elisp I wrote when first learning Emacs.  It is the central kernel around
which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

#+begin_src emacs-lisp
  ;; Stop stupid bell
  (setq ring-bell-function 'ignore)
#+end_src

The bell is really, /really/ annoying.

** Start a server for =emacsclient=

#+begin_src emacs-lisp
  (server-start)
#+end_src

** Don't hang when visiting files with extremely long lines

#+begin_src emacs-lisp
  (global-so-long-mode t)
#+end_src

** Unicode
Sometimes (especially on Windows), Emacs gets confused about what encoding to
use.  These settings try to prevent that confusion.

#+begin_src emacs-lisp
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

** Mode line
It's easy for the mode line to get cluttered once things like Flymake and eglot
kick in.  When I was starting out, I used to have these two settings:

#+begin_src emacs-lisp :tangle no :eval never
(setq display-battery-mode t
      display-time-day-and-date t)

(display-time)
#+end_src

After a while I noticed that I'm almost never running Emacs in a full screen
where I can't see the battery or date in the corner of my window manager, so
they were just wasting mode line space.  Nowadays I simply opt for column mode
and a dimmed mode line in non-selected windows.

#+begin_src emacs-lisp
  (setq column-number-mode t
        mode-line-in-non-selected-windows t)
#+end_src

** Remember minibuffer history
Found this on a [[https://www.youtube.com/watch?v=51eSeqcaikM][System Crafters video]].

#+begin_src emacs-lisp
  (setq history-length 25)
  (savehist-mode 1)
#+end_src

** Render ASCII color escape codes
For files containing color escape codes, this provides a way to render the
colors in-buffer.  Provided by a [[https://stackoverflow.com/a/3072831/13215205][helpful stackoverflow answer]].

#+begin_src emacs-lisp
  (defun renz/display-ansi-colors ()
    "Render colors in a buffer that contains ASCII color escape codes."
    (interactive)
    (require 'ansi-color)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))
#+end_src

*** Colored output in ~eshell~ and =*compilation*=
In =*compilation*= mode, we just use the "display colors" function from above.
Enable colors in the =*compilation*= buffer.

#+begin_src emacs-lisp
  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
#+end_src

For =eshell=, this is copy-pasted from a [[https://emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell][stack overflow question]].

#+begin_src emacs-lisp
  (add-hook 'eshell-preoutput-filter-functions  #'ansi-color-apply)
#+end_src

*** xterm-color
Soon, I'd like to swap out my hacks above for this more robust package:
https://github.com/atomontage/xterm-color/tree/master

** Recent files menu
This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

#+begin_src emacs-lisp
  (recentf-mode t)

  (defun renz/find-recent-file ()
    "Find a file that was recently visted using `completing-read'."
    (interactive)
    (find-file (completing-read "Find recent file: " recentf-list nil t)))
#+end_src

** Fill-column
Regardless of whether we're doing visual fill or hard fill, I like the default
at around 80 characters, and I'll manually change it per buffer if I want
something different

#+begin_src emacs-lisp
  (setq-default fill-column 80)
#+end_src

** Scroll bar
I toggle this one on/off sometimes depending on how I feel and which OS I'm
currently on.

#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

By default, though, I prefer it to be off when I start Emacs.

** Window margins and fringe
This hunk adds some space around all sides of each window so that we get a clear
space between the edge of the screen and the fringe.

#+begin_src emacs-lisp
  (defun renz/modify-margins ()
    "Add some space around each window."
    (interactive)
    (modify-all-frames-parameters
     '((right-divider-width . 40)
       (internal-border-width . 40)))
    (dolist (face '(window-divider
                    window-divider-first-pixel
                    window-divider-last-pixel))
      (face-spec-reset-face face)
      (set-face-foreground face (face-attribute 'default :background)))
    (set-face-background 'fringe (face-attribute 'default :background)))

  (renz/modify-margins)
#+end_src

We also need to make sure this runs each time we change the =ef-theme=, otherwise
the old background color will linger in the margins.

#+begin_src emacs-lisp
  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
#+end_src

** Automatically visit symlink sources
When navigating to a file that is a symlink, this automatically redirects us to
the source file it's pointing to.

#+begin_src emacs-lisp
  (setq find-file-visit-truename t)
  (setq vc-follow-symlinks t)
#+end_src

** Indent with spaces by default
For the most part I edit Python, SQL, Markdown, Org, and shell scripts.  All of
these favor spaces over tabs, so I prefer this as the default.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Generally, though, indentation behavior is set by major-mode functions, which
may or may not use Emacs' built-in indentation functions.  For instance, when
trying to find the functions behind indentation in shell mode, I came across
~smie.el~, whose introductory comments include this gem:

#+begin_quote
  OTOH we had to kill many chickens, read many coffee grounds, and practice
  untold numbers of black magic spells, to come up with the indentation code.
  Since then, some of that code has been beaten into submission, but the
  `smie-indent-keyword' function is still pretty obscure.
#+end_quote

Even the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html][GNU manual]] speaks of it in the same way:

#+begin_quote
  Writing a good indentation function can be difficult and to a large extent it is
  still a black art. Many major mode authors will start by writing a simple
  indentation function that works for simple cases, for example by comparing with
  the indentation of the previous text line. For most programming languages that
  are not really line-based, this tends to scale very poorly: improving such a
  function to let it handle more diverse situations tends to become more and more
  difficult, resulting in the end with a large, complex, unmaintainable
  indentation function which nobody dares to touch.
#+end_quote

** Enable horizontal scrolling with mouse
From a helpful [[https://stackoverflow.com/a/67758169][stackoverflow answer.]]

#+begin_src emacs-lisp
  (setq mouse-wheel-tilt-scroll t)
#+end_src

** Window management
From a Mickey Petersen [[https://www.masteringemacs.org/article/demystifying-emacs-window-manager][article]], this causes ~switch-to-buffer~ to open the
selected buffer in the current window rather than switching windows, assuming
both are open in the current frame.  This is more frequently the behavior I
intend when I'm trying to get a window to display a specific buffer.

#+begin_src emacs-lisp
  (unless (version< emacs-version "27.1")
    (setq switch-to-buffer-obey-display-actions t))
#+end_src

** Automatically update buffers when contents change on disk
Without setting ~global-auto-revert-mode~, we have to remember to issue a
~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
changed.  Over Tramp, we still have to manually revert files when they've
changed on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode)
#+end_src

** Highlight the line point is on
Add a faint background highlight to the line we're editing.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'hl-line-mode)
  (add-hook 'text-mode-hook #'hl-line-mode)
  (add-hook 'org-mode-hook #'hl-line-mode)
#+end_src

** Always turn on flymake in prog mode

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'flymake-mode)
#+end_src

Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
comments and strings.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
#+end_src

** Automatically create matching parens in programming modes

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook (electric-pair-mode t))
  (add-hook 'prog-mode-hook (show-paren-mode t))
#+end_src

** Shorten yes/no prompts to y/n

#+begin_src emacs-lisp
(setq use-short-answers t)
#+end_src

** Delete whitespace on save
I would also like to have a good-looking display for trailing whitespace and
leading tabs like in my Neovim setup, but it has proven challenging to just
narrow down to those two faces.  In the interim, I toggle ~M-x whitespace-mode~ to
check for mixed tabs, spaces, and line endings.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Killing buffers with a running process
Typically, Emacs will ask you to confirm before killing a buffer that has a
running process, such as with ~run-python~, a =*shell*= buffer, or a =*compilation*=
buffer.

#+begin_src emacs-lisp
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+end_src

** Don't wrap lines
I much prefer having long lines simply spill off to the right of the screen than
having them wrap around onto the next line, except in the case where I'd like to
see wrapped line content, like in one of the shell modes.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
#+end_src

** Relative line numbers
For programming and prose/writing modes.

Unfortunately, line numbers are displayed in the text area of the buffer, but
org-modern uses the fringe to display source blocks.  [[https://www.reddit.com/r/emacs/comments/ymprwi/comment/iv5iafb/?utm_source=share&utm_medium=web2x&context=3][There's no way to display
them to the left]] of the fringe, so I'm careful about only turning on line
numbers in modes that I think I'll benefit from it.  It's been working pretty
well in org-mode without the line numbers so far, since for each of the code
blocks I can always use =C-c '= to edit in ~prog-mode~, where I /do/ get line numbers.

#+begin_src emacs-lisp
  (defun renz/display-relative-lines ()
    (setq display-line-numbers 'relative))

  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)

  (unless (display-graphic-p)
    (add-hook 'text-mode-hook #'renz/display-relative-lines))
#+end_src

** Delete region when we yank on top of it
I just think that's a funny sentence.  Normally when yanking text with an active
region, the region will remain and the yanked text is just inserted at point.  I
prefer the modern word processor behavior of replacing the selected text with
the yanked content.

#+begin_src emacs-lisp
  (delete-selection-mode t)
#+end_src

** Enable mouse in terminal/TTY

#+begin_src emacs-lisp
  (xterm-mouse-mode 1)
#+end_src

** Compilation
As new text appears, the default behavior is for it to spill off the bottom,
unless we manually scroll to the end of the buffer.  Instead, I prefer the
window to automatically scroll along with text as it appears, stopping at the
first error that appears.

#+begin_src emacs-lisp
  (setq compilation-scroll-output 'first-error)
#+end_src

** Tool bar
I usually leave the tool bar disabled

#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
disable it on Windows, where it looks hideous if I'm running in dark mode.

#+begin_src emacs-lisp
  (when (renz/windowsp)
    (menu-bar-mode -1))
#+end_src

For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
it is the most straightforward way to discover Emacs' most useful features.

** Ignore risky .dir-locals.el
From an [[https://emacs.stackexchange.com/a/44604][Emacs stackexchange]] answer.

#+begin_src emacs-lisp
  (advice-add 'risky-local-variable-p :override #'ignore)
#+end_src

** =grep= and =find=

#+begin_src emacs-lisp
  (use-package grep
    :bind ("C-c g" . grep-find)
    :config
    (when (executable-find "rg")
      (setq grep-program "rg")
      (grep-apply-setting
       'grep-find-command
       '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42)))
    (when (executable-find "fd")
      (setq find-program "fd")))

#+end_src

If you're on Windows, this command assumes you're running =pwsh= version 7 or higher.

** Confirm when exiting Emacs
It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
instead hit ~C-x C-c~.  This helps prevent that.

#+begin_src emacs-lisp
  (setq confirm-kill-emacs 'yes-or-no-p)
#+end_src

** Smooth scrolling
Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
"jumpiness" you see when scrolling past images.

#+begin_src emacs-lisp
  (if (version< emacs-version "29.0")
      (pixel-scroll-mode)
    (pixel-scroll-precision-mode 1)
    (setq pixel-scroll-precision-large-scroll-height 35.0))
#+end_src

** Spellchecking
On macOS and linux I typically use =aspell=, given how easy it is to install.  For
Windows, I'll set up [[http://hunspell.github.io/][hunspell]], which I install from [[https://github.com/iquiw/hunspell-binary/releases/][the hunspell-binary repo]].
After installing the =hunspell= binary, it requires installing a dictionary and
affix file to the installation directory:

#+begin_src shell :tangle no :results none
  curl -o en_US.dic https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
  curl -o en_US.aff https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
#+end_src

Then move these files to wherever hunspell is.  For instance, =C:\Program Files\Hunspell=.

#+begin_src emacs-lisp
  (cond ((executable-find "aspell")
         (setq ispell-program-name "aspell"
               ispell-really-aspell t))
        ((executable-find "hunspell")
         (setq ispell-program-name "hunspell"
               ispell-really-hunspell t)))
#+end_src

Also on windows, you'll need to set up two things in your "System Environment
Variables," if you are able to edit it.  Assuming you installed Hunspell to
=%PROGRAMFILES%\Hunspell=, and you moved the =.dic= and =.aff= files to the same
directory, you'd set up your variables like this:

1. Add =%PROGRAMFILES%\Hunspell\bin= to your user =PATH=
2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%\Hunspell=

If you can't edit your System's environment variables through the GUI, say,
because you're on a VM you don't administer, then you'll have to set these two
environment variables through your powershell or CMD profiles.

** Backup and auto-save files
Keep all backup files in a temporary folder.  At the moment I have some "file
not found" errors popping up during auto-save on Windows.  Once I debug that,
I'll uncomment the second part.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
        ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
        )
#+end_src

** Enable ~narrow-to-region~
~narrow-to-region~ restricts editing in this buffer to the current region.  The
rest of the text becomes temporarily invisible and untouchable but is not
deleted; if you save the buffer in a file, the invisible text is included in the
file.  =C-x n w= makes all visible again.

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+end_src

** Enable up/downcase-region
Allows us to convert entire regions to upper or lower case.

#+begin_src emacs-lisp
  (put 'upcase-region 'disabled nil)
  (put 'downcase-region 'disabled nil)
#+end_src

** Mark rings and registers: bigger, faster, stronger
16 is the default number of marks stored on the global and local mark rings
is 16.  I hop around much more than 16 times as I'm editing, so I expand this a
bit.

#+begin_src emacs-lisp
  (setq-default mark-ring-max 32)
  (setq global-mark-ring-max 32)
#+end_src

Another handy shortcut is continually popping marks by repeated =C-<SPC>= after
the first =C-u C-<SPC>= through the ~set-mark-command-repeat-pop~ setting.

#+begin_src emacs-lisp
  (setq set-mark-command-repeat-pop t)
#+end_src

And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=.  The
local version, =C-u C-<SPC>= will only pop marks from the current buffer.  So the
=C-x C-<SPC>= version is much closer to how Vim's jump stack works.

A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
and files to registers pre-emptively.

#+begin_src emacs-lisp
  (set-register ?S '(buffer . "*scratch*"))
  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
  (set-register ?B `(file . "~/.bashrc"))
#+end_src

The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
the register.  My own personal convention here is to use lower-case letter for
interactive session bookmarks that will be lost between sessions, and upper-case
letters for ones I've set permanently here.

Before I was aware of this feature I had created my own ~jump-to-X~ style
functions, but this is much better!  You even get a handy pop-up if you wait a
second after typing =C-x r j= to see all the available registers.

* Keybindings

** Expanded/better defaults
These convenient chords allow for fast text replacement by holding =C-M-= and
rapidly typing =k= and =h= in succession.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
  (global-set-key (kbd "C-M-h") 'backward-kill-sexp)
#+end_src

The next line UNBINDS the suspend-frame keybinding.  Accidentally minimizing on
the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
suspend the frame.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-z") #'zap-up-to-char)
#+end_src

Hippie-expand [[https://www.masteringemacs.org/article/text-expansion-hippie-expand][is purported]] to be a better version of ~dabbrev~, but I rather like
the default behavior of ~dabbrev~.

#+begin_src emacs-lisp
  (global-set-key [remap dabbrev-expand] 'hippie-expand)
#+end_src

~ibuffer~ is a strictly superior, built-in version of its counterpart.

#+begin_src emacs-lisp
  (global-set-key [remap list-buffers] 'ibuffer)
#+end_src

The most common situation where I'm running ~flymake~ would be for spelling in
prose, or diagnostics from a language server.  In either case, I like having
next/previous on easy to reach chords.

#+begin_src emacs-lisp
  (use-package flymake
    :bind (:map flymake-mode-map
           ("C-c n" . flymake-goto-next-error)
           ("C-c p" . flymake-goto-prev-error)))
#+end_src

** Overriding defaults
Some default bindings aren't useful for me, so I bind them to actions I take
more frequently.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-p") 'previous-buffer)  ; Overrides `mark-page'
  (global-set-key (kbd "C-x C-n") 'next-buffer)      ; Overrides `set-goal-column'
#+end_src

** C-c bindings
Emacs has [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html][some standards]] about where user-configured keys should go; =C-c
<letter>= is always free for users.  It may seem like overkill how I set a header
for each possible =C-c= combination, but it's incredibly handy when I want to jump
directly to one of these headings while in another buffer.  See e.g. =org-goto=,
which allows me to narrow in on a particular key I'd like to bind by leveraging
=completing-read=.  If a =C-c <letter>= combination is missing as a header, then I'm
probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

*** =C-c b= build / compile

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c b") #'compile)
  (global-set-key (kbd "C-c B") #'recompile)
#+end_src

*** =C-c c= Insert current dir/file at point

#+begin_src emacs-lisp
  (defun renz/insert-current-dir ()
    "Insert the current `default-directory' at point."
    (interactive)
    (insert default-directory))

  (defun renz/insert-current-file ()
    "Insert the current buffer's full file name at point."
    (interactive)
    ;; https://unix.stackexchange.com/a/45381
    (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
#+end_src

*** =C-c d= Navigating to symbols using old-school TAGS

Before the whole language server revolution, we had TAGS files for caching the
location of symbol definitions.  =etags= comes with Emacs, and combining some
clever use of =find= with it can render a pretty good symbol search experience.
To generate the TAGS file, I usually have a =TAGS= recipe that looks something
similar to this in each project's =Makefile=:

#+begin_src shell
  find . -type d -name ".venv" -prune \
      -o -type d -name ".ipynb_checkpoints" -prune \
      -o -type d -name ".node_modules" -prune \
      -o -type d -name "elpa" -prune \
      -o -type f -name "*.py" -print \
      -o -type f -name "*.sql" -print \
      -o -type f -name "*.el" -print \
      | etags -
#+end_src

Then, =M-x project-compile RET make TAGS= builds a tags table.  At which point, I
can use =tags-completion-table= to build a list of symbols I can navigate to with
completion, with just a little help from =xref-find-definitions=.

#+begin_src emacs-lisp
  (defun renz/find-tag ()
    "Use `completing-read' to navigate to a tag."
    (interactive)
    (require 'etags)
    (tags-completion-table)
    (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

  (global-set-key (kbd "C-c d") #'renz/find-tag)
#+end_src

*** =C-c f= find file at point (ffap)

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c f") #'ffap)
#+end_src

*** =C-c i= browse url of buffer

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
#+end_src

*** =C-c j= Toggle window split
[[https://www.emacswiki.org/emacs/ToggleWindowSplit][Toggling windows]] from vertical to horizontal splits and vice-versa.

#+begin_src emacs-lisp
  (defun toggle-window-split ()
    "Switch between horizontal and vertical split window layout."
    (interactive)
    (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

  (global-set-key (kbd "C-c j") #'toggle-window-split)
#+end_src

*** =C-c k= kill all but one space

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c k") #'just-one-space)
#+end_src

*** =C-c q= replace regexp

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c q") #'replace-regexp)
#+end_src

*** =C-c r= find recent files

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
#+end_src

*** =C-c s= shell

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c s s") #'shell)
  (global-set-key (kbd "C-c s e") #'eshell)
  (global-set-key (kbd "C-c s t") #'term)
#+end_src

*** =C-c u= open URL at point in browser

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c u") #'browse-url-at-point)
#+end_src

*** =C-c v= faster git-commit

#+begin_src emacs-lisp
  (defun renz/git-commit ()
    (interactive)
    (vc-next-action nil)
    (log-edit-show-diff)
    (other-window 1))

  (global-set-key (kbd "C-c v") #'renz/git-commit)
#+end_src

*** =C-c w= whitespace mode

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c w") #'whitespace-mode)
#+end_src

*** =C-c= Other bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp)  ;; TTY-frindly
  (global-set-key (kbd "C-c <SPC>") #'mark-sexp)  ;; TTY-friendly
#+end_src

** F5-F9
Like the =C-c <letter>= bindings, these are reserved for users.  In practice, even
though there are few of these keys, I tend to forget which is which.  So I wind
up using things bound to my =C-c= keymaps instead.  The =C-c= kyes from a more
natural, nested language in my head, so it feels more like I'm "speaking Emacs"
that way.

** Super bindings

#+begin_src emacs-lisp
  (global-set-key (kbd "s-p") #'project-switch-project)
#+end_src

* Text Completion
Emacs offers incredible depth and freedom when configuring methods to
automatically complete text.  There are actually two things that
"autocompletion" can refer to in Emacs:

1. [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html][Minibuffer completion]]
2. [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html][Completion at point]]

Emacs on its own does not have a nice pop-up-menu like Vim for completing text
at point.  For both the minibuffer and ~completion-at-point~ it uses a special
buffer called ~*Completions*~, from which we can see (and optionally select) a
completion from potential candidates.  Before we get to tweak those settings,
though, we first need to oil the engine with an enhanced /completion style/

** Completion style
For both the minibuffer and ~completion-at-point~, I use the same /completion
style/.  Completion style is the method of assigning completion candidates to a
given input string.  ~flex~ is the built-in "fuzzy" completion style, familiar to
us from symbol completion in IDEs and VSCode's command palette.  ~basic~ functions
much like your default TAB-complete at a Bash shell.

#+begin_src emacs-lisp
  (setq completion-styles '(flex basic partial-completion emacs22))
#+end_src

** Nicer Display and Behavior of ~*Completions*~
With the /completion style/ set, we now have to configure the interface for
/displaying/ candidates as we type.  First, I want candidates displayed as a
single, vertical list.

#+begin_src emacs-lisp
  (setq completions-format 'one-column)
#+end_src

Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
sometimes take up the whole screen when there are a lot of candidates.

#+begin_src emacs-lisp
  (unless (version< emacs-version "29.0")
    (setq completions-max-height 15))
#+end_src

Some time ago, Prot wrote a package called [[https://github.com/protesilaos/mct/blob/main/mct.el][MCT]] (Minibuffer and Completions in
Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
to act more like what we expect of a modern editor's auto-complete.  He
discontinued development of that project once it became clear that Emacs 29 was
going to include similar behavior as a configurable option.  These are the
options in question.

#+begin_src emacs-lisp
  (unless (version< emacs-version "29.0")
    (setq completion-auto-help 'always
          completion-auto-select 'second-tab
          completion-show-help nil
          completions-sort nil
          completions-header-format nil))
#+end_src

** Completion in the minibuffer and at point
By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
I'd much prefer to use the easier and more intuitive =TAB=.

#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
something like a little window that updates as I type.  It seems a little wonky,
since TAB-completion will still cause the \ast{}Completions\ast{} buffer to pop up, even
while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
then it will still come up on the second TAB press.

#+begin_src emacs-lisp :tangle no
  (setq icomplete-in-buffer t)
  (setq icomplete-prospects-height 10)
  (icomplete-vertical-mode t)
#+end_src

In the case that we need to enter a new file name, but =fido= is still showing a
completion candidate, you have to use =C-d= to refuse completion and take whatever
is currently in the prompt.  For instance, if we are editing a file =hello.py=,
and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

* Language-specific major modes
** Shell (Bash, sh, ...)
#+begin_src emacs-lisp
  (defun renz/sh-indentation ()
    ;; (setq indent-tabs-mode t)
    (setq tab-width 8))

  (add-hook 'sh-mode-hook #'renz/sh-indentation)
  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
#+end_src
** HTML

This changes the behavior of a few commonly-used tags in web pages that I write.

#+begin_src emacs-lisp
  (use-package sgml-mode
    :defer t
    :config
    (let* ((p-tag-old (assoc "p" html-tag-alist))
           ;; Close the <p> tag and open on a new line.
           (p-tag-new `("p" \n ,(cdr (cdr p-tag-old)))))
      (add-to-list 'html-tag-alist p-tag-new)
      ;; Close the <code> tag and stay inline.
      (add-to-list 'html-tag-alist '("code"))))

#+end_src
** CSS

#+begin_src emacs-lisp
  (setq css-indent-offset 2)
#+end_src

For validation, grab [[https://github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar][css-validator.jar]] and execute it with java:

#+begin_example
java -jar ~/.local/jars/css-validator.jar file:///home/me/my/site/index.html
#+end_example

** Org-mode

#+begin_src emacs-lisp
  (setq renz/org-home "~/.emacs.d/org/")
#+end_src

~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
source file from within the tangled code.  ~renz/org-babel-tangle-jump-to-src~,
defined below, does the opposite - given the Org source file and point inside a
~src~ block, it jumps to the location of the tangled code.  Provided by a helpful
[[https://emacs.stackexchange.com/a/69591][stackoverflow answer.]]

#+begin_src emacs-lisp
  (defun renz/org-babel-tangle-jump-to-src ()
    "The opposite of `org-babel-tangle-jump-to-org'.
  Jumps to an Org src block from tangled code."
    (interactive)
    (if (org-in-block-p)
        (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
               (tangle (car header))
               (lang (caadr header))
               (buffer (nth 2 (cadr header)))
               (org-id (nth 3 (cadr header)))
               (source-name (nth 4 (cadr header)))
               (search-comment (org-fill-template
                                org-babel-tangle-comment-format-beg
                                `(("link" . ,org-id) ("source-name" . ,source-name))))
               (file (expand-file-name
                      (org-babel-effective-tangled-filename buffer lang tangle))))
          (if (not (file-exists-p file))
              (message "File does not exist. 'org-babel-tangle' first to create file.")
            (find-file file)
            (beginning-of-buffer)
            (search-forward search-comment)))
      (message "Cannot jump to tangled file because point is not at org src block.")))
#+end_src

Now we configure ~org-mode~ itself.  For a while I was trying =(setq
org-startup-indented t)= to get indentation under each header, but this was
interfering with the beautification features from ~org-modern~.  Preferring the
latter over the former, I've removed the =org-startup-indented= call.

#+begin_src emacs-lisp
  (defun renz/list-files-with-absolute-path (directory)
    "Return a list of files in DIRECTORY with their absolute paths."
    (cl-remove-if-not #'file-regular-p (directory-files directory t ".*\.org$")))

  (use-package org
    :hook
    ((org-mode . (lambda () (progn
                              (add-hook 'after-save-hook #'org-babel-tangle :append :local)
                              (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
                              (setq indent-tabs-mode nil)))))

    :init
    (defun renz/jump-org ()
      "Prompt for an org file in my emacs directory, then go there."
      (interactive)
      (renz/--jump-section renz/org-home "Org files: " ".*\.org$"))

    :bind
    (("C-c o a" . org-agenda)
     ("C-c o b d" . org-babel-detangle)
     ("C-c o b o" . org-babel-tangle-jump-to-org)
     ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
     ("C-c o k" . org-babel-remove-result)
     ("C-c o o" . renz/jump-org)
     ("C-c o y" . ox-clip-image-to-clipboard))

    :custom
    (org-image-actual-width nil "Enable resizing of images")
    (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
    (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
    (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
    (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
    (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

    :config
    (add-to-list 'org-modules 'org-tempo)
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (sql . t)
       (shell . t)
       (R . t)
       ;; (fortran . t)
       ;; (julia . t)
       ;; (jupyter . t)
       ;; (scheme . t)
       ;; (haskell . t)
       (lisp . t)
       ;; (clojure . t)
       ;; (C . t)
       ;; (org . t)
       ;; (gnuplot . t)
       ;; (awk . t)
       ;; (latex . t)
       )))
#+end_src

*** Converting JSON to Org Tables
I use a small external dependency for this:

#+begin_src emacs-lisp
  (use-package json-to-org-table
    :load-path "site-lisp/json-to-org-table/"
    :after org)
#+end_src

** SQL
*** DDL is SQL

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.ddl\\'" . sql-mode))
  (add-to-list 'auto-mode-alist '("\\.bql\\'" . sql-mode))
#+end_src

*** Indentation
Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
pretty.  I tend to format SQL like this:

#+begin_src sql :tangle no
  SELECT
      whatever,
      thing
  FROM
      wherever AS w
      JOIN the_other AS t ON w.id = t.id
  GROUP BY
      whatever
#+end_src

The configuration of =sql-indent= below achieves that nicely when using =RET= and
=TAB= for formatting.

#+begin_src emacs-lisp
  (defun renz/sql-mode-hook ()
    (setq tab-width 4))

  (defvar renz/sql-indentation-offsets-alist
    '((syntax-error sqlind-report-sytax-error)
      (in-string sqlind-report-runaway-string)
      (comment-continuation sqlind-indent-comment-continuation)
      (comment-start sqlind-indent-comment-start)
      (toplevel 0)
      (in-block +)
      (in-begin-block +)
      (block-start 0)
      (block-end 0)
      (declare-statement +)
      (package ++)
      (package-body 0)
      (create-statement +)
      (defun-start +)
      (labeled-statement-start 0)
      (statement-continuation +)
      (nested-statement-open sqlind-use-anchor-indentation +)
      (nested-statement-continuation sqlind-use-previous-line-indentation)
      (nested-statement-close sqlind-use-anchor-indentation)
      (with-clause sqlind-use-anchor-indentation)
      (with-clause-cte +)
      (with-clause-cte-cont ++)
      (case-clause 0)
      (case-clause-item sqlind-use-anchor-indentation +)
      (case-clause-item-cont sqlind-right-justify-clause)
      (select-clause 0)
      (select-column sqlind-indent-select-column)
      (select-column-continuation sqlind-indent-select-column +)
      (select-join-condition ++)
      (select-table sqlind-indent-select-table)
      (select-table-continuation sqlind-indent-select-table +)
      (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
      (insert-clause 0)
      (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
      (delete-clause 0)
      (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
      (update-clause 0)
      (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

  (defun renz/sql-indentation-offsets ()
    (setq sqlind-indentation-offsets-alist
          renz/sql-indentation-offsets-alist)
    (setq sqlind-basic-offset 4))

  (use-package sql-indent
    :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

  (use-package sql-mode
    :hook ((sql-mode . renz/sql-mode-hook)
           (sql-mode . sqlup-mode)
           (sql-mode . sqlind-minor-mode)))
#+end_src

*** Interactive ~hive2~ mode
This "hive2" package came from the days where I was working on an on-prem system
that used ~hive2~ as the main command-line interface to Hive.  I don't use this
much now, but it's a good reference for implementing a plug-in to a new
interactive SQL CLI.

#+begin_src emacs-lisp
  (use-package hive2
    :load-path "site-lisp/"
    :demand t
    :mode ("\\.hql" . sql-mode))
#+end_src

**** TODO COMMENT sql-formatter
I've modified [[https://github.com/purcell/sqlformat][sqlformat]] for use with [[https://www.npmjs.com/package/sql-formatter][sql-formatter]], but I need to find a way to
pass in a JSON of configuration values to the command line interface when we
call it.

#+begin_src emacs-lisp
  (use-package sqlformat
    :after (sql))
#+end_src

When I get to it, I think what I'll do instead is rewrite this to simply pipe
the current buffer into ~sql-formatter~, and use a bit of elisp to determine whether
a ~.sql-formatter-config.json~ exists in the VC root directory.

For the time being, though, I just pipe the file to an external ~sql-formatter~
process and redirect the output either to a new buffer, or the current buffer if
I'm happy with the results.

*** Interactive =bq shell=
The SQL interactive commands are looking for a single executable file, so let's
set that up somewhere common, like =~/.local/bin/bq-shell=.

#+begin_src shell :tangle no
  #!/usr/bin/env sh
  bq shell "$@"
#+end_src

Also, we don't want to use "legacy SQL" in our queries, which requires us to
configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
Google [[https://issuetracker.google.com/issues/35905841][issue tracker]].

#+begin_src :tangle ~/.bigqueryrc
[query]
--use_legacy_sql=false
#+end_src

Then enable the BQ product.

#+begin_src emacs-lisp
  (use-package bq
    :load-path "site-lisp"
    :demand t)
#+end_src

*** BigQuery ~sql~ Blocks in Org-Babel
#+OPTIONS: ^:nil
Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
:engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~.  More
commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
with it.

#+begin_src emacs-lisp
  (defun org-babel-execute:bq (orig-fun body params)
    (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
        (json-to-org-table-parse-json-string
         (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
                                  params))
      (org-babel-execute:sql body params)))

  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
#+end_src

This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
stop underscores from messing up how column names are displayed.

*** TODO BigQuery exception markers
When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
error markers to jump directly to the issue.

** Python
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
#+end_src
*** Pyright error links in =*compilation*=
The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
of the box, so I add that support myself.  Here's an example error message:

#+begin_example
/home/robb/tmp/errors.py/
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
parse file name, line, and column number.

#+begin_src emacs-lisp
  (with-eval-after-load 'compile
    (add-to-list 'compilation-error-regexp-alist-alist
                 '(pyright "^[[:blank:]]+\\(.+\\):\\([0-9]+\\):\\([0-9]+\\).*$" 1 2 3))
    (add-to-list 'compilation-error-regexp-alist 'pyright))
#+end_src

It would be nice if we could also capture the =\\(error\\|warning\\)= part as
"KIND", but I'm struggling to get it working.

*** Python check with "ruff"
Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
pre-specified linter.  Setting that to ~mypy~ or ~pyright~ if either of those
programs exist is a small time saver.

#+begin_src emacs-lisp
  (use-package python
    :config
    (require 'eglot)
    (setq python-check-command "ruff")
    (add-hook 'python-mode-hook #'flymake-mode)
    (add-hook 'python-ts-mode-hook #'flymake-mode)
    ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
    )
#+end_src


*** Fix Microsoft Windows Issues
At one point, I ran into something similar to this [[https://github.com/jorgenschaefer/elpy/issues/733][elpy issue]] on Windows.  The
culprit was "App Execution Aliases" with python and python3 redirecting to the
windows store.  Using this fixed it:

#+begin_example
     winkey -> Manage app execution aliases -> uncheck python and python3
#+end_example

Also on Windows - a =pip install= of =pyreadline3= is required to make
tab-completion work at all. It provides the =readline= import symbol.

*** Make check command and virtualenv root safe for .dir-locals.el
Virtualenvs require ~.dir-locals.el~ to have something like:

#+begin_src emacs-lisp :tangle no :eval never
((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
#+end_src

However, this only operates on `run-python' shells.  Also, for projects, we need to
make sure that setting the virtualenv root is marked as safe.

#+begin_src emacs-lisp
(put 'python-check-command 'safe-local-variable #'stringp)
(put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
(put 'pyvenv-default-virtual-env-name 'safe-local-variable #'stringp)
#+end_src

*** Emacs Jupyter?
Eventually, I would like to try the [[https://github.com/dzop/emacs-jupyter][emacs-jupyter]] package to interface with
Jupyter kernels from org-mode.

*** pyrightconfig.json

The most consistent way to get =eglot= to properly configure the python virtual
environment with =pyright= is to have a static file at the root of the project,
called ~pyrightconfig.json~.  I wrote a short plugin that allows me to select a
directory using =completing-read= and have Emacs write the content of
~pyrightconfig.json~ based on what I selected, in the appropriate directory.

#+begin_src emacs-lisp
  (use-package pyrightconfig
    :after (python))
#+end_src

Configuring pyright this way rather than "activating" an environment through
Emacs (ala =pythonic-activate= or similar) means we can be running the language
server in more than one project at a time, each pointing to its respective
virtual environment.

*** Activating Virtual Environments Over Tramp

#+begin_src emacs-lisp
  (use-package tramp-venv
    :bind
    (("C-c t v a" . tramp-venv-activate)
     ("C-c t v d" . tramp-venv-deactivate)))
#+end_src

*** Pyvenv for virtual environments

#+begin_src emacs-lisp
  (use-package pyvenv
    :init
    (if (eq system-type 'darwin)
        (setenv "WORKON_HOME" "~/micromamba/envs/")
      (setenv "WORKON_HOME" "~/.conda/envs/"))
    :bind
    (("C-c p w" . pyvenv-workon)
     ("C-c p d" . pyvenv-deactivate)
     ("C-c p a" . pyvenv-activate))
    :config
    (pyvenv-mode))
#+end_src

** Markdown
When installing =markdown= through Anaconda, the executable is actually called
=markdown_py=.  In case =markdown= isn't found, use that instead.

#+begin_src emacs-lisp
  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
    (setq markdown-command "markdown_py"))
#+end_src

Some folks like to write markdown without hard line breaks.  When viewing those
documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
it.

#+begin_src emacs-lisp
  (defun renz/md-hook ()
    "View buffer in visual fill mode with 80 character width."
    (interactive)
    (visual-fill-column-mode)
    (setq-local fill-column 80))
#+end_src

I make a lot of spelling mistakes as I type...

#+begin_src emacs-lisp
  (add-hook 'markdown-mode-hook 'flyspell-mode)
  (add-hook 'markdown-mode-hook 'auto-fill-mode)
#+end_src

And I like to see language syntax highlighting within code fences.

#+begin_src emacs-lisp
  (setq markdown-fontify-code-blocks-natively t)
#+end_src

** Missing auto-modes
These really should already be in =auto-mode-alist=, but aren't for some reason.

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.dockerfile\\'" . dockerfile-ts-mode))
#+end_src

** csv-mode
Handy for viewing data quickly.

#+begin_src emacs-lisp
  (use-package csv-mode
    :mode "\\.csv\\'")
#+end_src

* Tool configuration
These are tweaks for self-contained tooling, such as third party packages or
built-in packages that have a well-defined scope and namespace.

** =eldoc=
I find it very distracting when =eldoc= suddenly pops up and consumes a large part
of the screen for docstrings in python.

#+begin_src emacs-lisp
  (setq eldoc-echo-area-use-multiline-p nil)
#+end_src

** ~imenu~

#+begin_src emacs-lisp
  (use-package imenu
    :config
    (setq imenu-auto-rescan t
          org-imenu-depth 3))
#+end_src

** ~dabbrev~

#+begin_src emacs-lisp
  (use-package dabbrev
    :custom
    (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
  #+end_src

** ~dired~
By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes.  I
also have it hide the mode, size, and owner of each file by default.

#+begin_src emacs-lisp
  (use-package dired
    :hook (dired-mode . dired-hide-details-mode)
    :config
    (setq dired-listing-switches "-alFh")
    (setq dired-dwim-target t))
#+end_src

Also enabled above is Do-What-I-Mean (DWIM) copying.  This is for when two dired
windows are open, and we want to copy something from one location to the other.
By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
dired window's path when issuing a copy command with ~C~.

** Visual fill column
For visual lines, this adds line breaks at the fill-column value.  Especially
useful for prose that is meant to be copied to other mediums, such as email or
word.

#+begin_src emacs-lisp
  (use-package visual-fill-column
    :config
    (add-hook 'visual-line-mode-hook #'visual-fill-column-mode))
#+end_src

** eww - search engine and browser

Ecosia requires JavaScript, unfortunately.

#+begin_src emacs-lisp
  (use-package eww
    :config (setq eww-search-prefix "https://duckduckgo.com/html/?q="))
#+end_src

** Reloading Emacs
Often used when changing up my ~init.el~.

#+begin_src emacs-lisp
  (use-package restart-emacs
    :bind ("C-c x r" . restart-emacs))
#+end_src

** Language Server Protocol (LSP) with ~eglot~
As of version 29, [[https://github.com/joaotavora/eglot][eglot]] (Emacs polyGLOT) is bundled with Emacs.  It provides Emacs with the
client side configuration for the [[https://microsoft.github.io/language-server-protocol/][language server protocol]].

#+begin_src emacs-lisp
  (use-package eglot
    :bind (("C-c l c" . eglot-reconnect)
           ("C-c l d" . flymake-show-buffer-diagnostics)
           ("C-c l f f" . eglot-format)
           ("C-c l f b" . eglot-format-buffer)
           ("C-c l l" . eglot)
           ("C-c l r n" . eglot-rename)
           ("C-c l s" . eglot-shutdown)))
#+end_src

To have ~eglot~ always start up for a python buffer, we would tangle this line
into ~init.el~.  However, this can cause a significant loading delay over Tramp,
and I would prefer snappy, simple access with LSP provided on an as-needed
basis.

#+begin_src emacs-lisp :tangle no :eval never
(add-hook 'python-mode-hook 'eglot-ensure)
#+end_src

*** Side show: ~semantic-mode~
For a while, it looks like Emacs was trying out something called [[https://www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html][semantic-mode]],
which looks a lot like a precursor to what we now know as the [[https://microsoft.github.io/language-server-protocol/][Language Server
Protocol]].  Enabling it was done through adding the ~semantic-mode~ hook to your
language's major mode hook:

#+begin_src emacs-lisp :tangle no :eval never
(add-hook 'python-mode-hook 'semantic-mode)
#+end_src

** TreeSitter
*** About TreeSitter and its Load Paths
Emacs 29 added native [[https://tree-sitter.github.io/tree-sitter/][TreeSitter]] support.  TreeSitter is a new way of
incrementally parsing source code that offers superior navigation and syntax
highlighting.  To fully realize this benefit, however, it requires that we
install =tree-sitter= grammars independently from Emacs.  Right now, I'm using
[[https://github.com/casouri/tree-sitter-module][casouri's modules]], which I build and install under =~/.emacs.d/tree-sitter=, if
they don't already exist under =/usr/local/lib/= or =~/.local/lib=.  In case of the
latter, I just add extra paths to =treesit-extra-load-path= explicitly.

#+begin_src emacs-lisp
  (when (boundp 'treesit-extra-load-path)
    (add-to-list 'treesit-extra-load-path "/usr/local/lib/")
    (add-to-list 'treesit-extra-load-path "~/.local/lib/"))
#+end_src

For the full instructions, the commit history of adding the =tree-sitter= modules
to Emacs included a [[https://git.savannah.gnu.org/cgit/emacs.git/plain/admin/notes/tree-sitter/starter-guide?h=feature/tree-sitter][full guide]], which can be read in Info under "Parsing Program
Source".

#+begin_example
C-h i d m elisp RET g Parsing Program Source RET
#+end_example

Enabling TreeSitter is done on a per-language basis to override the default
major mode with the corresponding TreeSitter version.

*** Automatically Using TreeSitter Modes
I've posted this to GitHub and MELPA as [[https://github.com/renzmann/treesit-auto][treesit-auto]].

#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (global-treesit-auto-mode))
#+end_src

Before it was published to MELPA, I used a git subtree to manage the plugin.
This is a pretty useful technique, so I keep these two one-liners around in case
I need to reference or copy them.  To get a copy of something as a subtree, I
use this:

#+begin_src shell :results none
  git subtree add -P site-lisp/treesit-auto git@github.com:renzmann/treesit-auto main --squash
#+end_src

Fetching updates is a similar command.

#+begin_src shell :results none
  git subtree pull -P site-lisp/treesit-auto git@github.com:renzmann/treesit-auto main --squash
#+end_src

*** Ooo, aaah, shiny colors
I like to program "in Skittles":

#+begin_src emacs-lisp
  (setq-default treesit-font-lock-level 3)
#+end_src

** Tramp
Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
a remote machine, and edit them locally.  This is great for simple changes or
quickly testing out some Python on a VM somewhere.  It isn't as snappy as using
the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
set up Emacs remotely, I usually do.  When I don't want to or don't have the
time, Tramp is a godsend.  There are, however, many foibles to guard against,
particularly with how interacts with version control and ~.dir-locals~.  The
Tramp manual (distributed with Emacs) recommends adjusting these for some speed
improvements:

#+begin_src emacs-lisp
  (use-package tramp
    :defer t
    :config
    (setq vc-handled-backends '(Git)
          file-name-inhibit-locks t
          tramp-inline-compress-start-size 1000
          tramp-copy-size-limit 10000
          tramp-verbose 1)
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src

eglot is [[https://github.com/joaotavora/eglot/issues/859][actively working]] on an issue related to timers causing a "Forbidden
reentrant call of Tramp" message and freezing.  In the meantime, this setting
was recommended.

#+begin_src emacs-lisp
  (setq tramp-use-ssh-controlmaster-options nil)
#+end_src

For some time I was having a lot of trouble with prohibitive slowness over
Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
found out that enabling remote dir-locals was causing a huge bottleneck.  On
every operation it would trace up the filesystem tree back to the root
directory, scanning for a ~.dir-locals~ file.  Since some of the drives were
network-mounted, this caused thousands of network calls per file operation,
obviously slowing things down a lot.  Because of this, I've opted to simply
disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
all.

#+begin_src emacs-lisp :tangle no :eval never
;; (setq enable-remote-dir-locals t)
#+end_src

[[https://www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html][Disabling VC]] /does/ seem to speed things up a little, but it's not an acceptable
thing to put in, since I so frequently use VC over tramp.  Fully disabling VC
would include this snippet:

#+begin_src emacs-lisp :tangle no :eval never
(remove-hook 'find-file-hook 'vc-find-file-hook)

(setq vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))
#+end_src

Additionally, these came up as other potential options [[https://github.com/doomemacs/doomemacs/issues/3909][from the doom-emacs
issues]], which I do not currently include.

#+begin_src emacs-lisp :tangle no :eval never
(setq tramp-default-method "scp")
(setq projectile--mode-line "Projectile")
#+end_src

I often need to set these in ~/.ssh/config for TRAMP to speed up

#+begin_example
Host *
     ControlMaster auto
     ControlPath ~/.ssh/master-%h:%p
     ControlPersist 10m
     ForwardAgent yes
     ServerAliveInterval 60
#+end_example

** Shell commands

The Async command buffer's default behavior is to print =^M= characters (the
carriage return) instead of actually clearing text.  This is problematic for
spinners and progress bars, so I have a little hack to work around that.

#+begin_src emacs-lisp
  (defun renz/async-shell-command-filter-hook ()
    "Filter async shell command output via `comint-output-filter'."
    (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
      ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
      ;; are displayed
      (setq-local comint-inhibit-carriage-motion nil)
      (when-let ((proc (get-buffer-process (current-buffer))))
        ;; Attempting a solution found here:
        ;; https://gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
        (set-process-filter proc 'comint-output-filter))))


  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
#+end_src

There might be a better way, but this mostly works for now.

* Footer
Thank you for reading 'till the end or for being interested on how to end an
Emacs package.  So that's it, let's gracefully finish tangling everything:

#+begin_src emacs-lisp :comments no
(provide 'init.el)
;;; init.el ends here
#+end_src
