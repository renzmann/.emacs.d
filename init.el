;;; init.el --- Robb's Emacs configuration -*- lexical-binding: t -*-

;; Copyright (C) 2022 Robert Enzmann

;; Author: Robb Enzmann <robbenzmann@gmail.com>
;; Keywords: internal
;; URL: https://robbmann.io/

;;; Commentary:
;; A mostly minimal, reproducible Emacs configuration.  This file is
;; automatically tangled from README.org, with header/footer comments on each
;; code block that allow for de-tangling the source back to README.org when
;; working on this file directly.

;;; Code:

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
;;  (when (file-exists-p custom-file)
;;  (load custom-file 'noerror))
;; #+end_src

;; * Proxy settings
;; When behind a corporate proxy, we might have to authenticate before we can pull
;; packages off ELPA. Emacs only uses the HOST and PORT portions of the
;; =http_proxy= and =https_proxy= environment variables, so we need to set LOGIN
;; (user id) and PASSWORD ourselves.

;; I store the login, port, and host variables in a =proxy.el= file (obviously
;; outside version control) when I'm on a machine that's behind an http proxy. We
;; grab the password interactively when such a file exists.

;; #+begin_src emacs-lisp
;;  (defun renz/enable-proxy ()
;;  (interactive)
;;  "Turn on HTTP proxy."
;;  (let ((proxy-file (expand-file-name "proxy.el" user-emacs-directory)))
;;  (when (file-exists-p proxy-file)
;;  (load-file proxy-file)
;;  (setq url-proxy-services
;;  `(("no_proxy" . "^/(localhost/|10.*/)")
;;  ("http" . ,(concat renz/proxy-host ":" renz/proxy-port))
;;  ("https" . ,(concat renz/proxy-host ":" renz/proxy-port))))
;;  (setq url-http-proxy-basic-auth-storage
;;  (list
;;  (list
;;  (concat renz/proxy-host ":" renz/proxy-port)
;;  (cons renz/proxy-login
;;  (base64-encode-string
;;  (concat renz/proxy-login ":" (password-read "Proxy password: "))))))))))
;; #+end_src

;; * Packages
;; The initial cornerstone of every Emacs configuration is a decision on package
;; management and configuration. I opt for =use-package= and =package.el=, since both
;; are built-in to Emacs 29+, which helps maximize stability and portability.

;; To avoid loading packages twice, /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html/]/[the manual/]/] recommends disabling
;; ~package-enable-at-startup~ in ~init.el~.

;; #+begin_src emacs-lisp
;;  (require 'package)
;;  (setq package-enable-at-startup nil)
;;  (add-to-list 'package-archives
;;  '("melpa" . "https:/melpa.org/packages/") t)
;; #+end_src

;; I do not use the =:ensure t= keyword in =use-package= declarations to install
;; packages, because I cannot always ensure that I have a stable connection to GNU
;; ELPA (in the case of =package-install-selected-packages=) or the public
;; =github.com= (for =package-vc-install-selected-packages=). Instead, I rely on
;; =M-x package-install= and =M-x package-delete=, and only permit =use-package= to
;; handle the configuration and loading of packages. As mentioned in the
;; introduction, each package's source is explicitly included into version control
;; of my configuration, so I don't worry too much about pinning package versions in
;; this file. When I want to update a package, I use =M-x package-update=, the
;; =package.el= user interface, or delete the package's source folder and use
;; =renz/package-sync= (defined below). Should something go wrong, I roll back to
;; a previous commit. So far, this method has been reliable for keeping my
;; =init.el= (this README), =custom.el=, the =package-selected-packages= variable,
;; and =elpa/= directory all in sync with one another.

;; #+begin_src emacs-lisp
;;  (defun renz/package-sync ()
;;  "Remove unused sources and install any missing ones."
;;  (interactive)
;;  (package-autoremove)
;;  (package-install-selected-packages)
;;  (package-vc-install-selected-packages))

;;  (when (and (cl-notevery 'package-installed-p package-selected-packages)
;;  (yes-or-no-p "Install VC packages?"))
;;  (package-vc-install-selected-packages))
;; #+end_src

;; There are also a few hand-made packages I keep around in a special
;; ~.emacs.d/site-lisp~ directory.

;; #+begin_src emacs-lisp
;;  (add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
;; #+end_src

;; * OS-specific Configuration
;; ** Microsoft Windows

;; While /usable/ out of the box, Emacs will be far less productive without some
;; additional setup on a Windows machine. First thing's first, though; I need a
;; way within my lisp code to tell if we're running Windows.

;; #+begin_src emacs-lisp
;;  (defun renz/windowsp ()
;;  "Are we on Microsoft Windows?"
;;  (memq system-type '(windows-nt cygwin ms-dos)))
;; #+end_src

;; Then, there are a few things I set up independent of Emacs. Namely, =find=,
;; =xargs=, =gcc=, and =rg=, which unfortunately requires a detour through
;; =MINGW64=.

;; #+begin_src powershell :tangle no
;;  winget install MSYS2.MSYS2
;; #+end_src

;; Then, we open up the MINGW64 command prompt, and use =pacman= to get the
;; standard toolchain.

;; #+begin_src shell :tangle no
;;  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
;; #+end_src

;; I often forget these obtuse package names, so I'll search for them like this:

;; #+begin_src shell :tangle no
;;  pacman -Ss ripgrep
;; #+end_src

;; #+RESULTS:
;; | clangarm64/mingw-w64-clang-aarch64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw32/mingw-w64-i686-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw64/mingw-w64-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | ucrt64/mingw-w64-ucrt-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | clang64/mingw-w64-clang-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |

;; Copy the desired version with my mouse, and install it:

;; #+begin_src shell :tangle no
;;  pacman -S mingw-w64-x86_64-ripgrep
;; #+end_src

;; Finally, we have to modify the Windows PATH through the GUI (ew). I haven't
;; found any good method yet that avoids administrator privilages, since Windows
;; places the System PATH before the user PATH. I typically have to add these two
;; to the very front of the System PATH (/before/ =%SystemRoot%/system32=). This
;; is so the GNU version of =find= appears before the Windows default =FIND=
;; command, which is incompatible with Emacs.

;; + =C:/msys64/usr/bin=
;; + =C:/msys64/mingw64/bin=

;; Even with all of this setup in place, it's still tough to get Powershell to play
;; nicely with some of the shell quoting Emacs has to do when running external
;; programs like =find= and =grep=. For instance, if we were to set the
;; =shell-file-name= like this:

;; #+begin_src emacs-lisp :tangle no
;;  (when (and (renz/windowsp) (executable-find "pwsh"))
;;  (setq shell-file-name "pwsh"))
;; #+end_src

;; Then running =C-u C-x p f= (=project-find-file=), which augments the =find=
;; command to include files that would normally be ignored by =.gitignore=, we get
;; this nasty message:

;; #+begin_example
;;  project--files-in-directory: File listing failed: -path: The term '-path' is not recognized as a name of a cmdlet, function, script file, or executable program.
;;  Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
;; #+end_example

;; If we don't have admin privilages, there are some lisp alternatives to =find=
;; and =grep=, such as =M-x find-lisp-find-dired=

;; *** On the winkey
;; Windows, funnily enough, has some trouble registering the Windows key as a
;; usable modifier for Emacs. In fact, =s-l= will /never/ be an option, since it's
;; handled at the hardware level. For a time I considered enabling the use of the
;; winkey like this:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq w32-pass-lwindow-to-system nil)
;; (setq w32-lwindow-modifier 'super) ; Left Windows key
;; (setq w32-pass-rwindow-to-system nil)
;; (setq w32-rwindow-modifier 'super) ; Right Windows key
;; #+end_src

;; Followed by enabling specific chords, such as "winkey+a":

;; #+begin_src emacs-lisp :tangle no :eval never
;; (w32-register-hot-key /[s-a/])
;; #+end_src

;; Since I've taken a more TTY-friendly approach for my config in general, where
;; super can be a bit tough to integrate with both the windowing application /and/
;; the terminal emulator, I've mostly given up on the GUI key in favor of other
;; chords, especially the =C-c= ones.

;; ** macOS
;; Launching Emacs from the typical application launcher or command-space usually
;; won't capture any modifications to =$PATH=, typically handled in a file like
;; =~/.profile= or =~/.bashrc=. So, the main configuration included here is from
;; /[/[https:/github.com/purcell/exec-path-from-shell/]/[exec-path-from-shell/]/].

;; #+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Custom:1]]
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file 'noerror))
;; Custom:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (defun renz/enable-proxy ()
;;  (interactive)
;;  "Turn on HTTP proxy."
;;  (let ((proxy-file (expand-file-name "proxy.el" user-emacs-directory)))
;;  (when (file-exists-p proxy-file)
;;  (load-file proxy-file)
;;  (setq url-proxy-services
;;  `(("no_proxy" . "^/(localhost/|10.*/)")
;;  ("http" . ,(concat renz/proxy-host ":" renz/proxy-port))
;;  ("https" . ,(concat renz/proxy-host ":" renz/proxy-port))))
;;  (setq url-http-proxy-basic-auth-storage
;;  (list
;;  (list
;;  (concat renz/proxy-host ":" renz/proxy-port)
;;  (cons renz/proxy-login
;;  (base64-encode-string
;;  (concat renz/proxy-login ":" (password-read "Proxy password: "))))))))))
;; #+end_src

;; * Packages
;; The initial cornerstone of every Emacs configuration is a decision on package
;; management and configuration. I opt for =use-package= and =package.el=, since both
;; are built-in to Emacs 29+, which helps maximize stability and portability.

;; To avoid loading packages twice, /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Package-Installation.html/]/[the manual/]/] recommends disabling
;; ~package-enable-at-startup~ in ~init.el~.

;; #+begin_src emacs-lisp
;;  (require 'package)
;;  (setq package-enable-at-startup nil)
;;  (add-to-list 'package-archives
;;  '("melpa" . "https:/melpa.org/packages/") t)
;; #+end_src

;; I do not use the =:ensure t= keyword in =use-package= declarations to install
;; packages, because I cannot always ensure that I have a stable connection to GNU
;; ELPA (in the case of =package-install-selected-packages=) or the public
;; =github.com= (for =package-vc-install-selected-packages=). Instead, I rely on
;; =M-x package-install= and =M-x package-delete=, and only permit =use-package= to
;; handle the configuration and loading of packages. As mentioned in the
;; introduction, each package's source is explicitly included into version control
;; of my configuration, so I don't worry too much about pinning package versions in
;; this file. When I want to update a package, I use =M-x package-update=, the
;; =package.el= user interface, or delete the package's source folder and use
;; =renz/package-sync= (defined below). Should something go wrong, I roll back to
;; a previous commit. So far, this method has been reliable for keeping my
;; =init.el= (this README), =custom.el=, the =package-selected-packages= variable,
;; and =elpa/= directory all in sync with one another.

;; #+begin_src emacs-lisp
;;  (defun renz/package-sync ()
;;  "Remove unused sources and install any missing ones."
;;  (interactive)
;;  (package-autoremove)
;;  (package-install-selected-packages)
;;  (package-vc-install-selected-packages))

;;  (when (and (cl-notevery 'package-installed-p package-selected-packages)
;;  (yes-or-no-p "Install VC packages?"))
;;  (package-vc-install-selected-packages))
;; #+end_src

;; There are also a few hand-made packages I keep around in a special
;; ~.emacs.d/site-lisp~ directory.

;; #+begin_src emacs-lisp
;;  (add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
;; #+end_src

;; * OS-specific Configuration
;; ** Microsoft Windows

;; While /usable/ out of the box, Emacs will be far less productive without some
;; additional setup on a Windows machine. First thing's first, though; I need a
;; way within my lisp code to tell if we're running Windows.

;; #+begin_src emacs-lisp
;;  (defun renz/windowsp ()
;;  "Are we on Microsoft Windows?"
;;  (memq system-type '(windows-nt cygwin ms-dos)))
;; #+end_src

;; Then, there are a few things I set up independent of Emacs. Namely, =find=,
;; =xargs=, =gcc=, and =rg=, which unfortunately requires a detour through
;; =MINGW64=.

;; #+begin_src powershell :tangle no
;;  winget install MSYS2.MSYS2
;; #+end_src

;; Then, we open up the MINGW64 command prompt, and use =pacman= to get the
;; standard toolchain.

;; #+begin_src shell :tangle no
;;  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
;; #+end_src

;; I often forget these obtuse package names, so I'll search for them like this:

;; #+begin_src shell :tangle no
;;  pacman -Ss ripgrep
;; #+end_src

;; #+RESULTS:
;; | clangarm64/mingw-w64-clang-aarch64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw32/mingw-w64-i686-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw64/mingw-w64-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | ucrt64/mingw-w64-ucrt-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | clang64/mingw-w64-clang-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |

;; Copy the desired version with my mouse, and install it:

;; #+begin_src shell :tangle no
;;  pacman -S mingw-w64-x86_64-ripgrep
;; #+end_src

;; Finally, we have to modify the Windows PATH through the GUI (ew). I haven't
;; found any good method yet that avoids administrator privilages, since Windows
;; places the System PATH before the user PATH. I typically have to add these two
;; to the very front of the System PATH (/before/ =%SystemRoot%/system32=). This
;; is so the GNU version of =find= appears before the Windows default =FIND=
;; command, which is incompatible with Emacs.

;; + =C:/msys64/usr/bin=
;; + =C:/msys64/mingw64/bin=

;; Even with all of this setup in place, it's still tough to get Powershell to play
;; nicely with some of the shell quoting Emacs has to do when running external
;; programs like =find= and =grep=. For instance, if we were to set the
;; =shell-file-name= like this:

;; #+begin_src emacs-lisp :tangle no
;;  (when (and (renz/windowsp) (executable-find "pwsh"))
;;  (setq shell-file-name "pwsh"))
;; #+end_src

;; Then running =C-u C-x p f= (=project-find-file=), which augments the =find=
;; command to include files that would normally be ignored by =.gitignore=, we get
;; this nasty message:

;; #+begin_example
;;  project--files-in-directory: File listing failed: -path: The term '-path' is not recognized as a name of a cmdlet, function, script file, or executable program.
;;  Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
;; #+end_example

;; If we don't have admin privilages, there are some lisp alternatives to =find=
;; and =grep=, such as =M-x find-lisp-find-dired=

;; *** On the winkey
;; Windows, funnily enough, has some trouble registering the Windows key as a
;; usable modifier for Emacs. In fact, =s-l= will /never/ be an option, since it's
;; handled at the hardware level. For a time I considered enabling the use of the
;; winkey like this:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq w32-pass-lwindow-to-system nil)
;; (setq w32-lwindow-modifier 'super) ; Left Windows key
;; (setq w32-pass-rwindow-to-system nil)
;; (setq w32-rwindow-modifier 'super) ; Right Windows key
;; #+end_src

;; Followed by enabling specific chords, such as "winkey+a":

;; #+begin_src emacs-lisp :tangle no :eval never
;; (w32-register-hot-key /[s-a/])
;; #+end_src

;; Since I've taken a more TTY-friendly approach for my config in general, where
;; super can be a bit tough to integrate with both the windowing application /and/
;; the terminal emulator, I've mostly given up on the GUI key in favor of other
;; chords, especially the =C-c= ones.

;; ** macOS
;; Launching Emacs from the typical application launcher or command-space usually
;; won't capture any modifications to =$PATH=, typically handled in a file like
;; =~/.profile= or =~/.bashrc=. So, the main configuration included here is from
;; /[/[https:/github.com/purcell/exec-path-from-shell/]/[exec-path-from-shell/]/].

;; #+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Proxy settings:1]]
(defun renz/enable-proxy ()
  (interactive)
  "Turn on HTTP proxy."
  (let ((proxy-file (expand-file-name "proxy.el" user-emacs-directory)))
    (when (file-exists-p proxy-file)
      (load-file proxy-file)
      (setq url-proxy-services
            `(("no_proxy" . "^\\(localhost\\|10.*\\)")
              ("http" . ,(concat renz/proxy-host ":" renz/proxy-port))
              ("https" . ,(concat renz/proxy-host ":" renz/proxy-port))))
      (setq url-http-proxy-basic-auth-storage
            (list
             (list
              (concat renz/proxy-host ":" renz/proxy-port)
              (cons renz/proxy-login
                    (base64-encode-string
                     (concat renz/proxy-login ":" (password-read "Proxy password: "))))))))))
;; Proxy settings:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (require 'package)
;;  (setq package-enable-at-startup nil)
;;  (add-to-list 'package-archives
;;  '("melpa" . "https:/melpa.org/packages/") t)
;; #+end_src

;; I do not use the =:ensure t= keyword in =use-package= declarations to install
;; packages, because I cannot always ensure that I have a stable connection to GNU
;; ELPA (in the case of =package-install-selected-packages=) or the public
;; =github.com= (for =package-vc-install-selected-packages=). Instead, I rely on
;; =M-x package-install= and =M-x package-delete=, and only permit =use-package= to
;; handle the configuration and loading of packages. As mentioned in the
;; introduction, each package's source is explicitly included into version control
;; of my configuration, so I don't worry too much about pinning package versions in
;; this file. When I want to update a package, I use =M-x package-update=, the
;; =package.el= user interface, or delete the package's source folder and use
;; =renz/package-sync= (defined below). Should something go wrong, I roll back to
;; a previous commit. So far, this method has been reliable for keeping my
;; =init.el= (this README), =custom.el=, the =package-selected-packages= variable,
;; and =elpa/= directory all in sync with one another.

;; #+begin_src emacs-lisp
;;  (defun renz/package-sync ()
;;  "Remove unused sources and install any missing ones."
;;  (interactive)
;;  (package-autoremove)
;;  (package-install-selected-packages)
;;  (package-vc-install-selected-packages))

;;  (when (and (cl-notevery 'package-installed-p package-selected-packages)
;;  (yes-or-no-p "Install VC packages?"))
;;  (package-vc-install-selected-packages))
;; #+end_src

;; There are also a few hand-made packages I keep around in a special
;; ~.emacs.d/site-lisp~ directory.

;; #+begin_src emacs-lisp
;;  (add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
;; #+end_src

;; * OS-specific Configuration
;; ** Microsoft Windows

;; While /usable/ out of the box, Emacs will be far less productive without some
;; additional setup on a Windows machine. First thing's first, though; I need a
;; way within my lisp code to tell if we're running Windows.

;; #+begin_src emacs-lisp
;;  (defun renz/windowsp ()
;;  "Are we on Microsoft Windows?"
;;  (memq system-type '(windows-nt cygwin ms-dos)))
;; #+end_src

;; Then, there are a few things I set up independent of Emacs. Namely, =find=,
;; =xargs=, =gcc=, and =rg=, which unfortunately requires a detour through
;; =MINGW64=.

;; #+begin_src powershell :tangle no
;;  winget install MSYS2.MSYS2
;; #+end_src

;; Then, we open up the MINGW64 command prompt, and use =pacman= to get the
;; standard toolchain.

;; #+begin_src shell :tangle no
;;  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
;; #+end_src

;; I often forget these obtuse package names, so I'll search for them like this:

;; #+begin_src shell :tangle no
;;  pacman -Ss ripgrep
;; #+end_src

;; #+RESULTS:
;; | clangarm64/mingw-w64-clang-aarch64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw32/mingw-w64-i686-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw64/mingw-w64-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | ucrt64/mingw-w64-ucrt-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | clang64/mingw-w64-clang-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |

;; Copy the desired version with my mouse, and install it:

;; #+begin_src shell :tangle no
;;  pacman -S mingw-w64-x86_64-ripgrep
;; #+end_src

;; Finally, we have to modify the Windows PATH through the GUI (ew). I haven't
;; found any good method yet that avoids administrator privilages, since Windows
;; places the System PATH before the user PATH. I typically have to add these two
;; to the very front of the System PATH (/before/ =%SystemRoot%/system32=). This
;; is so the GNU version of =find= appears before the Windows default =FIND=
;; command, which is incompatible with Emacs.

;; + =C:/msys64/usr/bin=
;; + =C:/msys64/mingw64/bin=

;; Even with all of this setup in place, it's still tough to get Powershell to play
;; nicely with some of the shell quoting Emacs has to do when running external
;; programs like =find= and =grep=. For instance, if we were to set the
;; =shell-file-name= like this:

;; #+begin_src emacs-lisp :tangle no
;;  (when (and (renz/windowsp) (executable-find "pwsh"))
;;  (setq shell-file-name "pwsh"))
;; #+end_src

;; Then running =C-u C-x p f= (=project-find-file=), which augments the =find=
;; command to include files that would normally be ignored by =.gitignore=, we get
;; this nasty message:

;; #+begin_example
;;  project--files-in-directory: File listing failed: -path: The term '-path' is not recognized as a name of a cmdlet, function, script file, or executable program.
;;  Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
;; #+end_example

;; If we don't have admin privilages, there are some lisp alternatives to =find=
;; and =grep=, such as =M-x find-lisp-find-dired=

;; *** On the winkey
;; Windows, funnily enough, has some trouble registering the Windows key as a
;; usable modifier for Emacs. In fact, =s-l= will /never/ be an option, since it's
;; handled at the hardware level. For a time I considered enabling the use of the
;; winkey like this:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq w32-pass-lwindow-to-system nil)
;; (setq w32-lwindow-modifier 'super) ; Left Windows key
;; (setq w32-pass-rwindow-to-system nil)
;; (setq w32-rwindow-modifier 'super) ; Right Windows key
;; #+end_src

;; Followed by enabling specific chords, such as "winkey+a":

;; #+begin_src emacs-lisp :tangle no :eval never
;; (w32-register-hot-key /[s-a/])
;; #+end_src

;; Since I've taken a more TTY-friendly approach for my config in general, where
;; super can be a bit tough to integrate with both the windowing application /and/
;; the terminal emulator, I've mostly given up on the GUI key in favor of other
;; chords, especially the =C-c= ones.

;; ** macOS
;; Launching Emacs from the typical application launcher or command-space usually
;; won't capture any modifications to =$PATH=, typically handled in a file like
;; =~/.profile= or =~/.bashrc=. So, the main configuration included here is from
;; /[/[https:/github.com/purcell/exec-path-from-shell/]/[exec-path-from-shell/]/].

;; #+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Packages:1]]
(require 'package)
(setq package-enable-at-startup nil)
(add-to-list 'package-archives
             '("melpa" . "https://melpa.org/packages/") t)
;; Packages:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (defun renz/package-sync ()
;;  "Remove unused sources and install any missing ones."
;;  (interactive)
;;  (package-autoremove)
;;  (package-install-selected-packages)
;;  (package-vc-install-selected-packages))

;;  (when (and (cl-notevery 'package-installed-p package-selected-packages)
;;  (yes-or-no-p "Install VC packages?"))
;;  (package-vc-install-selected-packages))
;; #+end_src

;; There are also a few hand-made packages I keep around in a special
;; ~.emacs.d/site-lisp~ directory.

;; #+begin_src emacs-lisp
;;  (add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
;; #+end_src

;; * OS-specific Configuration
;; ** Microsoft Windows

;; While /usable/ out of the box, Emacs will be far less productive without some
;; additional setup on a Windows machine. First thing's first, though; I need a
;; way within my lisp code to tell if we're running Windows.

;; #+begin_src emacs-lisp
;;  (defun renz/windowsp ()
;;  "Are we on Microsoft Windows?"
;;  (memq system-type '(windows-nt cygwin ms-dos)))
;; #+end_src

;; Then, there are a few things I set up independent of Emacs. Namely, =find=,
;; =xargs=, =gcc=, and =rg=, which unfortunately requires a detour through
;; =MINGW64=.

;; #+begin_src powershell :tangle no
;;  winget install MSYS2.MSYS2
;; #+end_src

;; Then, we open up the MINGW64 command prompt, and use =pacman= to get the
;; standard toolchain.

;; #+begin_src shell :tangle no
;;  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
;; #+end_src

;; I often forget these obtuse package names, so I'll search for them like this:

;; #+begin_src shell :tangle no
;;  pacman -Ss ripgrep
;; #+end_src

;; #+RESULTS:
;; | clangarm64/mingw-w64-clang-aarch64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw32/mingw-w64-i686-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw64/mingw-w64-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | ucrt64/mingw-w64-ucrt-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | clang64/mingw-w64-clang-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |

;; Copy the desired version with my mouse, and install it:

;; #+begin_src shell :tangle no
;;  pacman -S mingw-w64-x86_64-ripgrep
;; #+end_src

;; Finally, we have to modify the Windows PATH through the GUI (ew). I haven't
;; found any good method yet that avoids administrator privilages, since Windows
;; places the System PATH before the user PATH. I typically have to add these two
;; to the very front of the System PATH (/before/ =%SystemRoot%/system32=). This
;; is so the GNU version of =find= appears before the Windows default =FIND=
;; command, which is incompatible with Emacs.

;; + =C:/msys64/usr/bin=
;; + =C:/msys64/mingw64/bin=

;; Even with all of this setup in place, it's still tough to get Powershell to play
;; nicely with some of the shell quoting Emacs has to do when running external
;; programs like =find= and =grep=. For instance, if we were to set the
;; =shell-file-name= like this:

;; #+begin_src emacs-lisp :tangle no
;;  (when (and (renz/windowsp) (executable-find "pwsh"))
;;  (setq shell-file-name "pwsh"))
;; #+end_src

;; Then running =C-u C-x p f= (=project-find-file=), which augments the =find=
;; command to include files that would normally be ignored by =.gitignore=, we get
;; this nasty message:

;; #+begin_example
;;  project--files-in-directory: File listing failed: -path: The term '-path' is not recognized as a name of a cmdlet, function, script file, or executable program.
;;  Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
;; #+end_example

;; If we don't have admin privilages, there are some lisp alternatives to =find=
;; and =grep=, such as =M-x find-lisp-find-dired=

;; *** On the winkey
;; Windows, funnily enough, has some trouble registering the Windows key as a
;; usable modifier for Emacs. In fact, =s-l= will /never/ be an option, since it's
;; handled at the hardware level. For a time I considered enabling the use of the
;; winkey like this:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq w32-pass-lwindow-to-system nil)
;; (setq w32-lwindow-modifier 'super) ; Left Windows key
;; (setq w32-pass-rwindow-to-system nil)
;; (setq w32-rwindow-modifier 'super) ; Right Windows key
;; #+end_src

;; Followed by enabling specific chords, such as "winkey+a":

;; #+begin_src emacs-lisp :tangle no :eval never
;; (w32-register-hot-key /[s-a/])
;; #+end_src

;; Since I've taken a more TTY-friendly approach for my config in general, where
;; super can be a bit tough to integrate with both the windowing application /and/
;; the terminal emulator, I've mostly given up on the GUI key in favor of other
;; chords, especially the =C-c= ones.

;; ** macOS
;; Launching Emacs from the typical application launcher or command-space usually
;; won't capture any modifications to =$PATH=, typically handled in a file like
;; =~/.profile= or =~/.bashrc=. So, the main configuration included here is from
;; /[/[https:/github.com/purcell/exec-path-from-shell/]/[exec-path-from-shell/]/].

;; #+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Packages:2]]
(defun renz/package-sync ()
  "Remove unused sources and install any missing ones."
  (interactive)
  (package-autoremove)
  (package-install-selected-packages)
  (package-vc-install-selected-packages))

(when (and (cl-notevery 'package-installed-p package-selected-packages)
           (yes-or-no-p "Install VC packages?"))
  (package-vc-install-selected-packages))
;; Packages:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
;; #+end_src

;; * OS-specific Configuration
;; ** Microsoft Windows

;; While /usable/ out of the box, Emacs will be far less productive without some
;; additional setup on a Windows machine. First thing's first, though; I need a
;; way within my lisp code to tell if we're running Windows.

;; #+begin_src emacs-lisp
;;  (defun renz/windowsp ()
;;  "Are we on Microsoft Windows?"
;;  (memq system-type '(windows-nt cygwin ms-dos)))
;; #+end_src

;; Then, there are a few things I set up independent of Emacs. Namely, =find=,
;; =xargs=, =gcc=, and =rg=, which unfortunately requires a detour through
;; =MINGW64=.

;; #+begin_src powershell :tangle no
;;  winget install MSYS2.MSYS2
;; #+end_src

;; Then, we open up the MINGW64 command prompt, and use =pacman= to get the
;; standard toolchain.

;; #+begin_src shell :tangle no
;;  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
;; #+end_src

;; I often forget these obtuse package names, so I'll search for them like this:

;; #+begin_src shell :tangle no
;;  pacman -Ss ripgrep
;; #+end_src

;; #+RESULTS:
;; | clangarm64/mingw-w64-clang-aarch64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw32/mingw-w64-i686-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw64/mingw-w64-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | ucrt64/mingw-w64-ucrt-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | clang64/mingw-w64-clang-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |

;; Copy the desired version with my mouse, and install it:

;; #+begin_src shell :tangle no
;;  pacman -S mingw-w64-x86_64-ripgrep
;; #+end_src

;; Finally, we have to modify the Windows PATH through the GUI (ew). I haven't
;; found any good method yet that avoids administrator privilages, since Windows
;; places the System PATH before the user PATH. I typically have to add these two
;; to the very front of the System PATH (/before/ =%SystemRoot%/system32=). This
;; is so the GNU version of =find= appears before the Windows default =FIND=
;; command, which is incompatible with Emacs.

;; + =C:/msys64/usr/bin=
;; + =C:/msys64/mingw64/bin=

;; Even with all of this setup in place, it's still tough to get Powershell to play
;; nicely with some of the shell quoting Emacs has to do when running external
;; programs like =find= and =grep=. For instance, if we were to set the
;; =shell-file-name= like this:

;; #+begin_src emacs-lisp :tangle no
;;  (when (and (renz/windowsp) (executable-find "pwsh"))
;;  (setq shell-file-name "pwsh"))
;; #+end_src

;; Then running =C-u C-x p f= (=project-find-file=), which augments the =find=
;; command to include files that would normally be ignored by =.gitignore=, we get
;; this nasty message:

;; #+begin_example
;;  project--files-in-directory: File listing failed: -path: The term '-path' is not recognized as a name of a cmdlet, function, script file, or executable program.
;;  Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
;; #+end_example

;; If we don't have admin privilages, there are some lisp alternatives to =find=
;; and =grep=, such as =M-x find-lisp-find-dired=

;; *** On the winkey
;; Windows, funnily enough, has some trouble registering the Windows key as a
;; usable modifier for Emacs. In fact, =s-l= will /never/ be an option, since it's
;; handled at the hardware level. For a time I considered enabling the use of the
;; winkey like this:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq w32-pass-lwindow-to-system nil)
;; (setq w32-lwindow-modifier 'super) ; Left Windows key
;; (setq w32-pass-rwindow-to-system nil)
;; (setq w32-rwindow-modifier 'super) ; Right Windows key
;; #+end_src

;; Followed by enabling specific chords, such as "winkey+a":

;; #+begin_src emacs-lisp :tangle no :eval never
;; (w32-register-hot-key /[s-a/])
;; #+end_src

;; Since I've taken a more TTY-friendly approach for my config in general, where
;; super can be a bit tough to integrate with both the windowing application /and/
;; the terminal emulator, I've mostly given up on the GUI key in favor of other
;; chords, especially the =C-c= ones.

;; ** macOS
;; Launching Emacs from the typical application launcher or command-space usually
;; won't capture any modifications to =$PATH=, typically handled in a file like
;; =~/.profile= or =~/.bashrc=. So, the main configuration included here is from
;; /[/[https:/github.com/purcell/exec-path-from-shell/]/[exec-path-from-shell/]/].

;; #+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Packages:3]]
(add-to-list 'load-path (expand-file-name "site-lisp/" user-emacs-directory))
;; Packages:3 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (defun renz/windowsp ()
;;  "Are we on Microsoft Windows?"
;;  (memq system-type '(windows-nt cygwin ms-dos)))
;; #+end_src

;; Then, there are a few things I set up independent of Emacs. Namely, =find=,
;; =xargs=, =gcc=, and =rg=, which unfortunately requires a detour through
;; =MINGW64=.

;; #+begin_src powershell :tangle no
;;  winget install MSYS2.MSYS2
;; #+end_src

;; Then, we open up the MINGW64 command prompt, and use =pacman= to get the
;; standard toolchain.

;; #+begin_src shell :tangle no
;;  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
;; #+end_src

;; I often forget these obtuse package names, so I'll search for them like this:

;; #+begin_src shell :tangle no
;;  pacman -Ss ripgrep
;; #+end_src

;; #+RESULTS:
;; | clangarm64/mingw-w64-clang-aarch64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw32/mingw-w64-i686-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | mingw64/mingw-w64-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | ucrt64/mingw-w64-ucrt-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |
;; | clang64/mingw-w64-clang-x86_64-ripgrep | 13.0.0-1 | | | | | | | | | | | | |
;; | line-oriented | search | tool | that | recursively | searches | your | current | directory | for | a | regex | pattern | (mingw-w64) |

;; Copy the desired version with my mouse, and install it:

;; #+begin_src shell :tangle no
;;  pacman -S mingw-w64-x86_64-ripgrep
;; #+end_src

;; Finally, we have to modify the Windows PATH through the GUI (ew). I haven't
;; found any good method yet that avoids administrator privilages, since Windows
;; places the System PATH before the user PATH. I typically have to add these two
;; to the very front of the System PATH (/before/ =%SystemRoot%/system32=). This
;; is so the GNU version of =find= appears before the Windows default =FIND=
;; command, which is incompatible with Emacs.

;; + =C:/msys64/usr/bin=
;; + =C:/msys64/mingw64/bin=

;; Even with all of this setup in place, it's still tough to get Powershell to play
;; nicely with some of the shell quoting Emacs has to do when running external
;; programs like =find= and =grep=. For instance, if we were to set the
;; =shell-file-name= like this:

;; #+begin_src emacs-lisp :tangle no
;;  (when (and (renz/windowsp) (executable-find "pwsh"))
;;  (setq shell-file-name "pwsh"))
;; #+end_src

;; Then running =C-u C-x p f= (=project-find-file=), which augments the =find=
;; command to include files that would normally be ignored by =.gitignore=, we get
;; this nasty message:

;; #+begin_example
;;  project--files-in-directory: File listing failed: -path: The term '-path' is not recognized as a name of a cmdlet, function, script file, or executable program.
;;  Check the spelling of the name, or if a path was included, verify that the path is correct and try again.
;; #+end_example

;; If we don't have admin privilages, there are some lisp alternatives to =find=
;; and =grep=, such as =M-x find-lisp-find-dired=

;; *** On the winkey
;; Windows, funnily enough, has some trouble registering the Windows key as a
;; usable modifier for Emacs. In fact, =s-l= will /never/ be an option, since it's
;; handled at the hardware level. For a time I considered enabling the use of the
;; winkey like this:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq w32-pass-lwindow-to-system nil)
;; (setq w32-lwindow-modifier 'super) ; Left Windows key
;; (setq w32-pass-rwindow-to-system nil)
;; (setq w32-rwindow-modifier 'super) ; Right Windows key
;; #+end_src

;; Followed by enabling specific chords, such as "winkey+a":

;; #+begin_src emacs-lisp :tangle no :eval never
;; (w32-register-hot-key /[s-a/])
;; #+end_src

;; Since I've taken a more TTY-friendly approach for my config in general, where
;; super can be a bit tough to integrate with both the windowing application /and/
;; the terminal emulator, I've mostly given up on the GUI key in favor of other
;; chords, especially the =C-c= ones.

;; ** macOS
;; Launching Emacs from the typical application launcher or command-space usually
;; won't capture any modifications to =$PATH=, typically handled in a file like
;; =~/.profile= or =~/.bashrc=. So, the main configuration included here is from
;; /[/[https:/github.com/purcell/exec-path-from-shell/]/[exec-path-from-shell/]/].

;; #+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Microsoft Windows:1]]
(defun renz/windowsp ()
  "Are we on Microsoft Windows?"
  (memq system-type '(windows-nt cygwin ms-dos)))
;; Microsoft Windows:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (when (eq system-type 'darwin)
;;  (setq exec-path-from-shell-arguments '("-l"))
;;  (exec-path-from-shell-initialize))
;; #+end_src

;; * Font
;; Fonts are a tricky business. See Emacs/Fonts in the manual (=C-h i=) for relevant
;; information on how checking and setting default fonts works:

;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Font-Lookup.html/]/[Searching for installed fonts/]/]
;; + /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Fonts.html/]/[Setting the default font/]/]

;; #+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][macOS:1]]
(when (eq system-type 'darwin)
  (setq exec-path-from-shell-arguments '("-l"))
  (exec-path-from-shell-initialize))
;; macOS:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (cond ((x-list-fonts "Hack Nerd Font")
;;  (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
;;  ;; ((x-list-fonts "Segoe UI Emoji")
;;  ;; (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
;;  )
;; #+end_src

;; If the font is the wrong size, starting with Emacs 29.1 you can use =C-x C-M-+=
;; and =C-x C-M--= to change the size /globally/.

;; * Theme

;; With the introduction of =modus-vivendi-tinted= in Emacs 29, I really have no
;; need for any external themes now. It is accessible, well optimized for
;; =org-mode= and =prog-mode=, and distributed with vanilla Emacs. Hats off to
;; /[/[https:/protesilaos.com/]/[Prot/]/] for these wonderful themes.

;; #+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Font:1]]
(cond ((x-list-fonts "Hack Nerd Font")
       (add-to-list 'default-frame-alist '(font . "Hack Nerd Font-12")))
      ;; ((x-list-fonts "Segoe UI Emoji")
      ;;  (add-to-list 'default-frame-alist '(font . "Segoe UI Emoji-12")))
      )
;; Font:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (use-package emacs
;;  :custom
;;  (modus-themes-inhibit-reload nil)
;;  (modus-themes-subtle-line-numbers t)
;;  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
;;  (modus-themes-diffs 'desaturated)
;;  (modus-themes-hl-line 'intense)
;;  (modus-themes-deuteranopia nil)
;;  (modus-themes-bold-constructs t)
;;  (modus-themes-italic-constructs t)
;;  (modus-themes-mode-line 'borderless)
;;  (modus-themes-org-blocks 'gray-background)
;;  :bind ("<f5>" . modus-themes-toggle)
;;  :config
;;  (load-theme 'modus-vivendi-tinted t))
;; #+end_src

;; ** Window margins and fringe
;; This hunk adds some space around all sides of each window so that we get a clear
;; space between the edge of the screen and the fringe.

;; #+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Theme:1]]
(use-package emacs
  :custom
  (modus-themes-inhibit-reload nil)
  (modus-themes-subtle-line-numbers t)
  (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments))
  (modus-themes-diffs 'desaturated)
  (modus-themes-hl-line 'intense)
  (modus-themes-deuteranopia nil)
  (modus-themes-bold-constructs t)
  (modus-themes-italic-constructs t)
  (modus-themes-mode-line 'borderless)
  (modus-themes-org-blocks 'gray-background)
  :bind   ("<f5>" . modus-themes-toggle)
  :config
  (load-theme 'modus-vivendi-tinted t))
;; Theme:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (defun renz/modify-margins ()
;;  "Add some space around each window."
;;  (interactive)
;;  (modify-all-frames-parameters
;;  '((right-divider-width . 40)
;;  (internal-border-width . 40)))
;;  (dolist (face '(window-divider
;;  window-divider-first-pixel
;;  window-divider-last-pixel))
;;  (face-spec-reset-face face)
;;  (set-face-foreground face (face-attribute 'default :background)))
;;  (set-face-background 'fringe (face-attribute 'default :background)))

;;  (renz/modify-margins)
;; #+end_src

;; We also need to make sure this runs each time we change the =ef-theme=, otherwise
;; the old background color will linger in the margins.

;; #+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Window margins and fringe:1]]
(defun renz/modify-margins ()
  "Add some space around each window."
  (interactive)
  (modify-all-frames-parameters
   '((right-divider-width . 40)
     (internal-border-width . 40)))
  (dolist (face '(window-divider
                  window-divider-first-pixel
                  window-divider-last-pixel))
    (face-spec-reset-face face)
    (set-face-foreground face (face-attribute 'default :background)))
  (set-face-background 'fringe (face-attribute 'default :background)))

(renz/modify-margins)
;; Window margins and fringe:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; #+end_src

;; * Emacs' Built-in Settings
;; My settings for base Emacs behavior. Assuming I ran with /no/ plugins (ala ~emacs
;; -Q~), I would still set most of these by hand at one point or another. This
;; section is designed for variables that modify Emacs and its editing behavior
;; directly. Configuration for built-in tools, such as Dired, Tramp, and
;; Tree-sitter are located under /[/[* Tool configuration/]/[Tool configuration/]/].

;; ** Stop stupid bell
;; This snippet has a special place in my heart, because it was the first two lines
;; of elisp I wrote when first learning Emacs. It is the central kernel around
;; which my =~/.emacs= and later =~/.emacs.d/init.el= grew.

;; #+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Window margins and fringe:2]]
(add-hook 'ef-themes-post-load-hook 'renz/modify-margins)
;; Window margins and fringe:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  ;; Stop stupid bell
;;  (setq ring-bell-function 'ignore)
;; #+end_src

;; The bell is really, /really/ annoying.

;; ** Start a server for =emacsclient=

;; #+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Stop stupid bell:1]]
;; Stop stupid bell
(setq ring-bell-function 'ignore)
;; Stop stupid bell:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (server-start)
;; #+end_src

;; ** Don't hang when visiting files with extremely long lines

;; #+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Start a server for =emacsclient=:1]]
(server-start)
;; Start a server for =emacsclient=:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (global-so-long-mode t)
;; #+end_src

;; ** Unicode
;; Sometimes (especially on Windows), Emacs gets confused about what encoding to
;; use. These settings try to prevent that confusion.

;; #+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Don't hang when visiting files with extremely long lines:1]]
(global-so-long-mode t)
;; Don't hang when visiting files with extremely long lines:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (prefer-coding-system 'utf-8)
;;  (set-default-coding-systems 'utf-8)
;;  (set-terminal-coding-system 'utf-8)
;;  (set-keyboard-coding-system 'utf-8)
;;  (setq default-buffer-file-coding-system 'utf-8)
;;  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; #+end_src

;; ** Mode line
;; It's easy for the mode line to get cluttered once things like Flymake and eglot
;; kick in. When I was starting out, I used to have these two settings:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq display-battery-mode t
;;  display-time-day-and-date t)

;; (display-time)
;; #+end_src

;; After a while I noticed that I'm almost never running Emacs in a full screen
;; where I can't see the battery or date in the corner of my window manager, so
;; they were just wasting mode line space. Nowadays I simply opt for column mode
;; and a dimmed mode line in non-selected windows.

;; #+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Unicode:1]]
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(setq default-buffer-file-coding-system 'utf-8)
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
;; Unicode:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq column-number-mode t
;;  mode-line-in-non-selected-windows t)
;; #+end_src

;; ** Remember minibuffer history
;; Found this on a /[/[https:/www.youtube.com/watch?v=51eSeqcaikM/]/[System Crafters video/]/].

;; #+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Mode line:2]]
(setq column-number-mode t
      mode-line-in-non-selected-windows t)
;; Mode line:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (savehist-mode 1)
;; #+end_src

;; ** Render ASCII color escape codes
;; For files containing color escape codes, this provides a way to render the
;; colors in-buffer. Provided by a /[/[https:/stackoverflow.com/a/3072831/13215205/]/[helpful stackoverflow answer/]/].

;; #+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Remember minibuffer history:1]]
(savehist-mode 1)
;; Remember minibuffer history:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (defun renz/display-ansi-colors ()
;;  "Render colors in a buffer that contains ASCII color escape codes."
;;  (interactive)
;;  (require 'ansi-color)
;;  (let ((inhibit-read-only t))
;;  (ansi-color-apply-on-region (point-min) (point-max))))
;; #+end_src

;; *** Colored output in ~eshell~ and =*compilation*=
;; In =*compilation*= mode, we just use the "display colors" function from above.
;; Enable colors in the =*compilation*= buffer.

;; #+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Render ASCII color escape codes:1]]
(defun renz/display-ansi-colors ()
  "Render colors in a buffer that contains ASCII color escape codes."
  (interactive)
  (require 'ansi-color)
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region (point-min) (point-max))))
;; Render ASCII color escape codes:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; #+end_src

;; For =eshell=, this is copy-pasted from a /[/[https:/emacs.stackexchange.com/questions/9517/colored-git-output-in-eshell/]/[stack overflow question/]/].

;; #+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Colored output in ~eshell~ and =*compilation*=:1]]
(add-hook 'compilation-filter-hook #'renz/display-ansi-colors)
;; Colored output in ~eshell~ and =*compilation*=:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply)
;; #+end_src

;; *** xterm-color
;; Soon, I'd like to swap out my hacks above for this more robust package:
;; https:/github.com/atomontage/xterm-color/tree/master

;; ** Recent files menu
;; This enables "File -> Open Recent" from the menu bar and using ~completing-read~ over the ~recentf-list~.

;; #+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Colored output in ~eshell~ and =*compilation*=:2]]
(add-hook 'eshell-preoutput-filter-functions  #'ansi-color-apply)
;; Colored output in ~eshell~ and =*compilation*=:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (recentf-mode t)

;;  (defun renz/find-recent-file ()
;;  "Find a file that was recently visted using `completing-read'."
;;  (interactive)
;;  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; #+end_src

;; ** Fill-column
;; Regardless of whether we're doing visual fill or hard fill, I like the default
;; at around 80 characters, and I'll manually change it per buffer if I want
;; something different

;; #+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Recent files menu:1]]
(recentf-mode t)

(defun renz/find-recent-file ()
  "Find a file that was recently visted using `completing-read'."
  (interactive)
  (find-file (completing-read "Find recent file: " recentf-list nil t)))
;; Recent files menu:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq-default fill-column 80)
;; #+end_src

;; ** Scroll bar
;; I toggle this one on/off sometimes depending on how I feel and which OS I'm
;; currently on.

;; #+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Fill-column:1]]
(setq-default fill-column 80)
;; Fill-column:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (scroll-bar-mode -1)
;; #+end_src

;; By default, though, I prefer it to be off when I start Emacs.

;; ** Automatically visit symlink sources
;; When navigating to a file that is a symlink, this automatically redirects us to
;; the source file it's pointing to.

;; #+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Scroll bar:1]]
(scroll-bar-mode -1)
;; Scroll bar:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq find-file-visit-truename t)
;;  (setq vc-follow-symlinks t)
;; #+end_src

;; ** Indent with spaces by default
;; For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of
;; these favor spaces over tabs, so I prefer this as the default.

;; #+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Automatically visit symlink sources:1]]
(setq find-file-visit-truename t)
(setq vc-follow-symlinks t)
;; Automatically visit symlink sources:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq-default indent-tabs-mode nil)
;; #+end_src

;; Generally, though, indentation behavior is set by major-mode functions, which
;; may or may not use Emacs' built-in indentation functions. For instance, when
;; trying to find the functions behind indentation in shell mode, I came across
;; ~smie.el~, whose introductory comments include this gem:

;; #+begin_quote
;;  OTOH we had to kill many chickens, read many coffee grounds, and practice
;;  untold numbers of black magic spells, to come up with the indentation code.
;;  Since then, some of that code has been beaten into submission, but the
;;  `smie-indent-keyword' function is still pretty obscure.
;; #+end_quote

;; Even the /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Auto_002dIndentation.html/]/[GNU Emacs manual/]/] speaks of it in the same way:

;; #+begin_quote
;;  Writing a good indentation function can be difficult and to a large extent it is
;;  still a black art. Many major mode authors will start by writing a simple
;;  indentation function that works for simple cases, for example by comparing with
;;  the indentation of the previous text line. For most programming languages that
;;  are not really line-based, this tends to scale very poorly: improving such a
;;  function to let it handle more diverse situations tends to become more and more
;;  difficult, resulting in the end with a large, complex, unmaintainable
;;  indentation function which nobody dares to touch.
;; #+end_quote

;; ** Enable horizontal scrolling with mouse
;; From a helpful /[/[https:/stackoverflow.com/a/67758169/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Indent with spaces by default:1]]
(setq-default indent-tabs-mode nil)
;; Indent with spaces by default:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq mouse-wheel-tilt-scroll t)
;; #+end_src

;; ** Window management
;; From a Mickey Petersen /[/[https:/www.masteringemacs.org/article/demystifying-emacs-window-manager/]/[article/]/], this causes ~switch-to-buffer~ to open the
;; selected buffer in the current window rather than switching windows, assuming
;; both are open in the current frame. This is more frequently the behavior I
;; intend when I'm trying to get a window to display a specific buffer.

;; #+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Enable horizontal scrolling with mouse:1]]
(setq mouse-wheel-tilt-scroll t)
;; Enable horizontal scrolling with mouse:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq switch-to-buffer-obey-display-actions t)
;; #+end_src

;; ** Automatically update buffers when contents change on disk
;; Without setting ~global-auto-revert-mode~, we have to remember to issue a
;; ~revert-buffer~ or ~revert-buffer-quick~ (=C-x x g= by default) in case a file
;; changed. Over Tramp, we still have to manually revert files when they've
;; changed on disk.

;; #+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Window management:1]]
(setq switch-to-buffer-obey-display-actions t)
;; Window management:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (global-auto-revert-mode)
;; #+end_src

;; ** Highlight the line point is on
;; Add a faint background highlight to the line we're editing.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Automatically update buffers when contents change on disk:1]]
(global-auto-revert-mode)
;; Automatically update buffers when contents change on disk:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'hl-line-mode)
;;  (add-hook 'text-mode-hook #'hl-line-mode)
;;  (add-hook 'org-mode-hook #'hl-line-mode)
;; #+end_src

;; ** Always turn on flymake in prog mode

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Highlight the line point is on:1]]
(add-hook 'prog-mode-hook #'hl-line-mode)
(add-hook 'text-mode-hook #'hl-line-mode)
(add-hook 'org-mode-hook #'hl-line-mode)
;; Highlight the line point is on:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flymake-mode)
;; #+end_src

;; Another, related mode is ~flyspell-prog-mode~, which is just checks spelling in
;; comments and strings.

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Always turn on flymake in prog mode:1]]
(add-hook 'prog-mode-hook #'flymake-mode)
;; Always turn on flymake in prog mode:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; #+end_src

;; ** Automatically create matching parentheses in programming modes

;; #+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Always turn on flymake in prog mode:2]]
(add-hook 'prog-mode-hook #'flyspell-prog-mode)
;; Always turn on flymake in prog mode:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'prog-mode-hook (electric-pair-mode t))
;;  (add-hook 'prog-mode-hook (show-paren-mode t))
;; #+end_src

;; ** Shorten yes/no prompts to y/n

;; #+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Automatically create matching parentheses in programming modes:1]]
(add-hook 'prog-mode-hook (electric-pair-mode t))
(add-hook 'prog-mode-hook (show-paren-mode t))
;; Automatically create matching parentheses in programming modes:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;; (setq use-short-answers t)
;; #+end_src

;; ** Delete whitespace on save
;; I would also like to have a good-looking display for trailing whitespace and
;; leading tabs like in my Neovim setup, but it has proven challenging to just
;; narrow down to those two faces. In the interim, I toggle ~M-x whitespace-mode~
;; to check for mixed tabs, spaces, and line endings.

;; #+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Shorten yes/no prompts to y/n:1]]
(setq use-short-answers t)
;; Shorten yes/no prompts to y/n:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (add-hook 'before-save-hook 'delete-trailing-whitespace)
;; #+end_src

;; ** Killing buffers with a running process
;; Typically, Emacs will ask you to confirm before killing a buffer that has a
;; running process, such as with ~run-python~, a =*shell*= buffer, or a
;; =*compilation*= buffer.

;; #+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Delete whitespace on save:1]]
(add-hook 'before-save-hook 'delete-trailing-whitespace)
;; Delete whitespace on save:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;; (delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; #+end_src

;; ** Don't wrap lines
;; I much prefer having long lines simply spill off to the right of the screen than
;; having them wrap around onto the next line, except in the case where I'd like to
;; see wrapped line content, like in one of the shell modes.

;; #+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Killing buffers with a running process:1]]
(delete 'process-kill-buffer-query-function kill-buffer-query-functions)
;; Killing buffers with a running process:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq-default truncate-lines t)
;;  (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
;;  (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; #+end_src

;; ** Relative line numbers
;; For programming and prose/writing modes. For large, folded files (like this
;; README), I had an issue where the relative line numbers wouldn't line up, and
;; looked like this:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/d05f019b5a4e0dcac1048e3ecfe995655610957f/img/bad-line-numbers.gif

;; Super distracting. Setting =display-line-numbers-width= to 3 so that the
;; thousands place lines up looks pretty darn good no matter how many lines are in
;; the document. It's very infrequent that I'd have to open up a file in the 10's
;; of thousands of lines, so this is working great so far.

;; #+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Don't wrap lines:1]]
(setq-default truncate-lines t)
(add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil)))
(add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil)))
;; Don't wrap lines:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (defun renz/display-relative-lines ()
;;  (setq display-line-numbers-width 3)
;;  (setq display-line-numbers 'relative))

;;  (add-hook 'prog-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'yaml-mode-hook #'renz/display-relative-lines)
;;  (add-hook 'text-mode-hook #'renz/display-relative-lines)
;; #+end_src

;; The result:

;; #+attr_html: :width 400px
;; https:/github.com/renzmann/.emacs.d/blob/e7298cf8188bc08a643feb797f1108ad0187cac6/img/good-line-numbers.gif

;; ** Delete region when we yank on top of it
;; I just think that's a funny sentence. Normally when yanking text with an active
;; region, the region will remain and the yanked text is just inserted at point. I
;; prefer the modern word processor behavior of replacing the selected text with
;; the yanked content.

;; #+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Relative line numbers:1]]
(defun renz/display-relative-lines ()
  (setq display-line-numbers-width 3)
  (setq display-line-numbers 'relative))

(add-hook 'prog-mode-hook #'renz/display-relative-lines)
(add-hook 'yaml-mode-hook #'renz/display-relative-lines)
(add-hook 'text-mode-hook #'renz/display-relative-lines)
;; Relative line numbers:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (delete-selection-mode t)
;; #+end_src

;; ** Enable mouse in terminal/TTY

;; #+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Delete region when we yank on top of it:1]]
(delete-selection-mode t)
;; Delete region when we yank on top of it:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (xterm-mouse-mode 1)
;; #+end_src

;; ** Compilation
;; As new text appears, the default behavior is for it to spill off the bottom,
;; unless we manually scroll to the end of the buffer. Instead, I prefer the
;; window to automatically scroll along with text as it appears, stopping at the
;; first error that appears.

;; #+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Enable mouse in terminal/TTY:1]]
(xterm-mouse-mode 1)
;; Enable mouse in terminal/TTY:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq compilation-scroll-output 'first-error)
;; #+end_src

;; ** Tool bar
;; I usually leave the tool bar disabled

;; #+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Compilation:1]]
(setq compilation-scroll-output 'first-error)
;; Compilation:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (tool-bar-mode -1)
;; #+end_src

;; The /menu/ bar, on the other hand =(menu-bar-mode)=, is very handy, and I only
;; disable it on Windows, where it looks hideous if I'm running in dark mode.

;; #+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Tool bar:1]]
(tool-bar-mode -1)
;; Tool bar:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (when (renz/windowsp)
;;  (menu-bar-mode -1))
;; #+end_src

;; For newcomers to Emacs, I would strongly discourage disabling the menu bar, as
;; it is the most straightforward way to discover Emacs' most useful features.

;; ** Ignore risky .dir-locals.el
;; From an /[/[https:/emacs.stackexchange.com/a/44604/]/[Emacs stackexchange/]/] answer.

;; #+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Tool bar:2]]
(when (renz/windowsp)
  (menu-bar-mode -1))
;; Tool bar:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (advice-add 'risky-local-variable-p :override #'ignore)
;; #+end_src

;; ** =grep= and =find=

;; #+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Ignore risky .dir-locals.el:1]]
(advice-add 'risky-local-variable-p :override #'ignore)
;; Ignore risky .dir-locals.el:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (use-package grep
;;  :bind ("C-c g" . grep-find)
;;  :config
;;  (when (executable-find "rg")
;;  (setq grep-program "rg")
;;  (grep-apply-setting 'grep-find-command
;;  '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
;;  (setq xref-search-program 'ripgrep)

;;  ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
;;  ;; this to work won't be quite as simple.
;;  ;;
;;  ;; (when (executable-find "fd")
;;  ;; (setq find-program "fd")
;;  ;; (setq find-ls-option nil))
;;  ))
;; #+end_src

;; If you're on Windows, this command assumes you're running =pwsh= version 7 or
;; higher.

;; ** Confirm when exiting Emacs
;; It's very annoying when I'm working and suddenly I meant to do ~C-c C-x~, but
;; instead hit ~C-x C-c~. This helps prevent that.

;; #+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][=grep= and =find=:1]]
(use-package grep
  :bind ("C-c g" . grep-find)
  :config
  (when (executable-find "rg")
    (setq grep-program "rg")
    (grep-apply-setting 'grep-find-command
                        '("rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)" . 42))
    (setq xref-search-program 'ripgrep)

    ;; "find . {}" is hard coded into `find-dired', so unfortunately getting
    ;; this to work won't be quite as simple.
    ;;
    ;; (when (executable-find "fd")
    ;;   (setq find-program "fd")
    ;;   (setq find-ls-option nil))
  ))
;; =grep= and =find=:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq confirm-kill-emacs 'yes-or-no-p)
;; #+end_src

;; ** Smooth scrolling
;; Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the
;; "jumpiness" you see when scrolling past images.

;; #+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Confirm when exiting Emacs:1]]
(setq confirm-kill-emacs 'yes-or-no-p)
;; Confirm when exiting Emacs:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (if (version< emacs-version "29.0")
;;  (pixel-scroll-mode)
;;  (pixel-scroll-precision-mode 1)
;;  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; #+end_src

;; ** Spellchecking
;; On macOS and linux I typically use =aspell=, given how easy it is to install. For
;; Windows, I'll set up /[/[http:/hunspell.github.io/]/[hunspell/]/], which I install from /[/[https:/github.com/iquiw/hunspell-binary/releases/]/[the hunspell-binary repo/]/].
;; After installing the =hunspell= binary, it requires installing a dictionary and
;; affix file to the installation directory:

;; #+begin_src shell :tangle no :results none
;;  curl -o en_US.dic https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;;  curl -o en_US.aff https:/cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f
;; #+end_src

;; Then move these files to wherever hunspell is. For instance, =C:/Program Files/Hunspell=.

;; #+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Smooth scrolling:1]]
(if (version< emacs-version "29.0")
    (pixel-scroll-mode)
  (pixel-scroll-precision-mode 1)
  (setq pixel-scroll-precision-large-scroll-height 35.0))
;; Smooth scrolling:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (cond ((executable-find "aspell")
;;  (setq ispell-program-name "aspell"
;;  ispell-really-aspell t))
;;  ((executable-find "hunspell")
;;  (setq ispell-program-name "hunspell"
;;  ispell-really-hunspell t)))
;; #+end_src

;; Also on windows, you'll need to set up two things in your "System Environment
;; Variables," if you are able to edit it. Assuming you installed Hunspell to
;; =%PROGRAMFILES%/Hunspell=, and you moved the =.dic= and =.aff= files to the same
;; directory, you'd set up your variables like this:

;; 1. Add =%PROGRAMFILES%/Hunspell/bin= to your user =PATH=
;; 2. Add a new variable =DICPATH= under "User variables" with value =%PROGRAMFILES%/Hunspell=

;; If you can't edit your System's environment variables through the GUI, say,
;; because you're on a VM you don't administer, then you'll have to set these two
;; environment variables through your powershell or CMD profiles.

;; ** Backup and auto-save files
;; Keep all backup files in a temporary folder. At the moment I have some "file
;; not found" errors popping up during auto-save on Windows. Once I debug that,
;; I'll uncomment the second part.

;; #+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Spellchecking:2]]
(cond ((executable-find "aspell")
       (setq ispell-program-name "aspell"
             ispell-really-aspell t))
      ((executable-find "hunspell")
       (setq ispell-program-name "hunspell"
             ispell-really-hunspell t)))
;; Spellchecking:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
;;  ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
;;  )
;; #+end_src

;; ** Enable ~narrow-to-region~
;; ~narrow-to-region~ restricts editing in this buffer to the current region. The
;; rest of the text becomes temporarily invisible and untouchable but is not
;; deleted; if you save the buffer in a file, the invisible text is included in the
;; file. =C-x n w= makes all visible again.

;; #+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Backup and auto-save files:1]]
(setq backup-directory-alist '(("." . "~/.emacs.d/backups/"))
      ;; auto-save-file-name-transforms '(("." ,temporary-file-directory t))
      )
;; Backup and auto-save files:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (put 'narrow-to-region 'disabled nil)
;; #+end_src

;; ** Enable up/downcase-region
;; Allows us to convert entire regions to upper or lower case.

;; #+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Enable ~narrow-to-region~:1]]
(put 'narrow-to-region 'disabled nil)
;; Enable ~narrow-to-region~:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (put 'upcase-region 'disabled nil)
;;  (put 'downcase-region 'disabled nil)
;; #+end_src

;; ** Mark rings and registers: bigger, faster, stronger
;; 16 is the default number of marks stored on the global and local mark rings
;; is 16. I hop around much more than 16 times as I'm editing, so I expand this a
;; bit.

;; #+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Enable up/downcase-region:1]]
(put 'upcase-region 'disabled nil)
(put 'downcase-region 'disabled nil)
;; Enable up/downcase-region:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq-default mark-ring-max 32)
;;  (setq global-mark-ring-max 32)
;; #+end_src

;; And, because I always forget it, to pop a global mark you use =C-x C-<SPC>=. The
;; local version, =C-u C-<SPC>= will only pop marks from the current buffer. So the
;; =C-x C-<SPC>= version is much closer to how Vim's jump stack works.

;; A handy "bookmark" system (aside from actual bookmarks) is to set common buffers
;; and files to registers pre-emptively.

;; #+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Mark rings and registers: bigger, faster, stronger:1]]
(setq-default mark-ring-max 32)
(setq global-mark-ring-max 32)
;; Mark rings and registers: bigger, faster, stronger:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (set-register ?S '(buffer . "*scratch*"))
;;  (set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
;;  (set-register ?B `(file . "~/.bashrc"))
;; #+end_src

;; The default keybinding for ~jump-to-register~ is =C-x r j R=, where =R= is the name of
;; the register. My own personal convention here is to use lower-case letter for
;; interactive session bookmarks that will be lost between sessions, and upper-case
;; letters for ones I've set permanently here.

;; Before I was aware of this feature I had created my own ~jump-to-X~ style
;; functions, but this is much better! You even get a handy pop-up if you wait a
;; second after typing =C-x r j= to see all the available registers.

;; ** =eldoc=
;; I find it very distracting when =eldoc= suddenly pops up and consumes a large part
;; of the screen for docstrings in python.

;; #+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][Mark rings and registers: bigger, faster, stronger:2]]
(set-register ?S '(buffer . "*scratch*"))
(set-register ?I `(file . ,(expand-file-name "README.org" user-emacs-directory)))
(set-register ?B `(file . "~/.bashrc"))
;; Mark rings and registers: bigger, faster, stronger:2 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (setq eldoc-echo-area-use-multiline-p nil)
;; #+end_src

;; ** ~imenu~

;; #+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][=eldoc=:1]]
(setq eldoc-echo-area-use-multiline-p nil)
;; =eldoc=:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (use-package imenu
;;  :config
;;  (setq imenu-auto-rescan t
;;  org-imenu-depth 3))
;; #+end_src

;; ** ~dabbrev~

;; Skip over image and PDF buffers when collecting candidates for dynamic
;; abbreviation.


;; #+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][~imenu~:1]]
(use-package imenu
  :config
  (setq imenu-auto-rescan t
        org-imenu-depth 3))
;; ~imenu~:1 ends here

;; [[file:README.org::+begin_src emacs-lisp
;;  (use-package dabbrev
;;  :custom
;;  (dabbrev-ignored-buffer-regexps '("/(?:pdf/|jpe?g/|png/)/'")))
;; #+end_src

;; Hippie-expand /[/[https:/www.masteringemacs.org/article/text-expansion-hippie-expand/]/[is purported/]/] to be a better version of ~dabbrev~.

;; #+begin_src emacs-lisp][~dabbrev~:1]]
(use-package dabbrev
  :custom
  (dabbrev-ignored-buffer-regexps '("\\.\\(?:pdf\\|jpe?g\\|png\\)\\'")))
;; ~dabbrev~:1 ends here

;; [[file:README.org::+begin_src emacs-lisp][~dabbrev~:2]]
(use-package hippie-exp
  :config
  (global-set-key [remap dabbrev-expand] 'hippie-expand)
  (delete 'try-expand-line hippie-expand-try-functions-list)
  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; ~dabbrev~:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.][~dired~:1]]
(use-package dired
  :hook (dired-mode . dired-hide-details-mode)
  :config
  (setq dired-listing-switches "-alFh")
  (setq dired-dwim-target t))
;; ~dired~:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.][eww - search engine and browser:1]]
(use-package eww
  :config (setq eww-search-prefix "https://duckduckgo.com/html/?q="))
;; eww - search engine and browser:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].][Language Server Protocol (LSP) with ~eglot~:1]]
(use-package eglot
  :bind (("C-c l c" . eglot-reconnect)
         ("C-c l d" . flymake-show-buffer-diagnostics)
         ("C-c l f f" . eglot-format)
         ("C-c l f b" . eglot-format-buffer)
         ("C-c l l" . eglot)
         ("C-c l r n" . eglot-rename)
         ("C-c l s" . eglot-shutdown)))
;; Language Server Protocol (LSP) with ~eglot~:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.][Shell commands:1]]
(defun renz/async-shell-command-filter-hook ()
  "Filter async shell command output via `comint-output-filter'."
  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
    ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
    ;; are displayed
    (setq-local comint-inhibit-carriage-motion nil)
    (when-let ((proc (get-buffer-process (current-buffer))))
      ;; Attempting a solution found here:
      ;; https://gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
      (set-process-filter proc 'comint-output-filter))))

(add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; Shell commands:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:][Tramp:1]]
(use-package tramp
  :defer t
  :config
  (setq vc-handled-backends '(Git)
        file-name-inhibit-locks t
        tramp-inline-compress-start-size 1000
        tramp-copy-size-limit 10000
        tramp-verbose 1)
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; Tramp:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults][Expanded/better defaults:1]]
(global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; Expanded/better defaults:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.][Expanded/better defaults:2]]
(global-set-key (kbd "C-z") #'zap-up-to-char)
;; Expanded/better defaults:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.][Expanded/better defaults:3]]
(global-set-key [remap list-buffers] 'ibuffer)
;; Expanded/better defaults:3 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.][Expanded/better defaults:4]]
(use-package flymake
  :bind (:map flymake-mode-map
         ("C-c n" . flymake-goto-next-error)
         ("C-c p" . flymake-goto-prev-error)))
;; Expanded/better defaults:4 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.][Overriding defaults:1]]
(global-set-key (kbd "C-x C-p") 'previous-buffer)  ; Overrides `mark-page'
(global-set-key (kbd "C-x C-n") 'next-buffer)      ; Overrides `set-goal-column'
;; Overriding defaults:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile][=C-c b= build / compile:1]]
(global-set-key (kbd "C-c b") #'compile)
(global-set-key (kbd "C-c B") #'recompile)
;; =C-c b= build / compile:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point][=C-c c= Insert current dir/file at point:1]]
(defun renz/insert-current-dir ()
  "Insert the current `default-directory' at point."
  (interactive)
  (insert default-directory))

(defun renz/insert-current-file ()
  "Insert the current buffer's full file name at point."
  (interactive)
  ;; https://unix.stackexchange.com/a/45381
  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

(global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
(global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; =C-c c= Insert current dir/file at point:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.][=C-c d= Navigating to symbols using old-school TAGS:2]]
(defun renz/find-tag ()
  "Use `completing-read' to navigate to a tag."
  (interactive)
  (require 'etags)
  (tags-completion-table)
  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

(global-set-key (kbd "C-c d") #'renz/find-tag)
;; =C-c d= Navigating to symbols using old-school TAGS:2 ends here

;; [[file:README.org::use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap][=C-c f= find file at point (ffap):1]]
(global-set-key (kbd "C-c f") #'ffap)
;; =C-c f= find file at point (ffap):1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer][=C-c i= browse url of buffer:1]]
(global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; =C-c i= browse url of buffer:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.][=C-c j= Toggle window split:1]]
(defun toggle-window-split ()
  "Switch between horizontal and vertical split window layout."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(global-set-key (kbd "C-c j") #'toggle-window-split)
;; =C-c j= Toggle window split:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space][=C-c k= kill all but one space:1]]
(global-set-key (kbd "C-c k") #'just-one-space)
;; =C-c k= kill all but one space:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp][=C-c q= replace regexp:1]]
(global-set-key (kbd "C-c q") #'replace-regexp)
;; =C-c q= replace regexp:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files][=C-c r= find recent files:1]]
(global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; =C-c r= find recent files:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell][=C-c s= shell:1]]
(global-set-key (kbd "C-c s s") #'shell)
(global-set-key (kbd "C-c s e") #'eshell)
(global-set-key (kbd "C-c s t") #'term)
;; =C-c s= shell:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser][=C-c u= open URL at point in browser:1]]
(global-set-key (kbd "C-c u") #'browse-url-at-point)
;; =C-c u= open URL at point in browser:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit][=C-c v= faster git-commit:1]]
(defun renz/git-commit ()
  (interactive)
  (vc-next-action nil)
  (log-edit-show-diff)
  (other-window 1))

(global-set-key (kbd "C-c v") #'renz/git-commit)
;; =C-c v= faster git-commit:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode][=C-c w= whitespace mode:1]]
(global-set-key (kbd "C-c w") #'whitespace-mode)
;; =C-c w= whitespace mode:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands][=C-c x= misc. "execute" commands:1]]
(global-set-key (kbd "C-c x r") #'restart-emacs)
;; =C-c x= misc. "execute" commands:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings][=C-c= Other bindings:1]]
(global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp)  ;; TTY-frindly
(global-set-key (kbd "C-c <SPC>") #'mark-sexp)  ;; TTY-friendly
;; =C-c= Other bindings:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings][Super bindings:1]]
(global-set-key (kbd "s-p") #'project-switch-project)
;; Super bindings:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.][Completion style:1]]
(setq completion-styles '(flex basic partial-completion emacs22))
;; Completion style:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.][Nicer Display and Behavior of ~*Completions*~:1]]
(setq completions-format 'one-column)
;; Nicer Display and Behavior of ~*Completions*~:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.][Nicer Display and Behavior of ~*Completions*~:2]]
(unless (version< emacs-version "29.0")
  (setq completions-max-height 15))
;; Nicer Display and Behavior of ~*Completions*~:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.][Nicer Display and Behavior of ~*Completions*~:3]]
(unless (version< emacs-version "29.0")
  (setq completion-auto-help 'always
        completion-auto-select 'second-tab
        completion-show-help nil
        completions-sort nil
        completions-header-format nil))
;; Nicer Display and Behavior of ~*Completions*~:3 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.][Completion in the minibuffer and at point:1]]
(setq tab-always-indent 'complete)
;; Completion in the minibuffer and at point:1 ends here

;; [[file:README.org::use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...][Shell (Bash, sh, ...):1]]
(defun renz/sh-indentation ()
  ;; (setq indent-tabs-mode t)
  (setq tab-width 8))

(add-hook 'sh-mode-hook #'renz/sh-indentation)
(add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; Shell (Bash, sh, ...):1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.][HTML:1]]
(use-package sgml-mode
  :defer t
  :config
  (let* ((p-tag-old (assoc "p" html-tag-alist))
         ;; Close the <p> tag and open on a new line.
         (p-tag-new `("p" \n ,(cdr (cdr p-tag-old)))))
    (add-to-list 'html-tag-alist p-tag-new)
    ;; Close the <code> tag and stay inline.
    (add-to-list 'html-tag-alist '("code"))))
;; HTML:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS][CSS:1]]
(setq css-indent-offset 2)
;; CSS:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode][Org-mode:1]]
(setq renz/org-home "~/.emacs.d/org/")
;; Org-mode:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]][Org-mode:2]]
(defun renz/org-babel-tangle-jump-to-src ()
  "The opposite of `org-babel-tangle-jump-to-org'.
Jumps to an Org src block from tangled code."
  (interactive)
  (if (org-in-block-p)
      (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
             (tangle (car header))
             (lang (caadr header))
             (buffer (nth 2 (cadr header)))
             (org-id (nth 3 (cadr header)))
             (source-name (nth 4 (cadr header)))
             (search-comment (org-fill-template
                              org-babel-tangle-comment-format-beg
                              `(("link" . ,org-id) ("source-name" . ,source-name))))
             (file (expand-file-name
                    (org-babel-effective-tangled-filename buffer lang tangle))))
        (if (not (file-exists-p file))
            (message "File does not exist. 'org-babel-tangle' first to create file.")
          (find-file file)
          (beginning-of-buffer)
          (search-forward search-comment)))
    (message "Cannot jump to tangled file because point is not at org src block.")))
;; Org-mode:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.][Org-mode:3]]
(defun renz/list-files-with-absolute-path (directory)
  "Return a list of files in DIRECTORY with their absolute paths."
  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*\.org$")))

(use-package org
  :hook
  ((org-mode . (lambda () (progn
                            (add-hook 'after-save-hook #'org-babel-tangle :append :local)
                            (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
                            (setq indent-tabs-mode nil)))))

  :init
  (defun renz/jump-org ()
    "Prompt for an org file in my emacs directory, then go there."
    (interactive)
    (renz/--jump-section renz/org-home "Org files: " ".*\.org$"))

  :bind
  (("C-c o a" . org-agenda)
   ("C-c o b d" . org-babel-detangle)
   ("C-c o b o" . org-babel-tangle-jump-to-org)
   ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
   ("C-c o k" . org-babel-remove-result)
   ("C-c o o" . renz/jump-org)
   ("C-c o y" . ox-clip-image-to-clipboard))

  :custom
  (org-image-actual-width nil "Enable resizing of images")
  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

  :config
  (add-to-list 'org-modules 'org-tempo)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)
     (sql . t)
     (shell . t)
     (R . t)
     ;; (fortran . t)
     ;; (julia . t)
     ;; (jupyter . t)
     ;; (scheme . t)
     ;; (haskell . t)
     (lisp . t)
     ;; (clojure . t)
     ;; (C . t)
     ;; (org . t)
     ;; (gnuplot . t)
     ;; (awk . t)
     ;; (latex . t)
     )))
;; Org-mode:3 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL][DDL is SQL:1]]
(add-to-list 'auto-mode-alist '("\\.ddl\\'" . sql-mode))
(add-to-list 'auto-mode-alist '("\\.bql\\'" . sql-mode))
;; DDL is SQL:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.][Indentation:2]]
(defun renz/sql-mode-hook ()
  (setq tab-width 4))

(defvar renz/sql-indentation-offsets-alist
  '((syntax-error sqlind-report-sytax-error)
    (in-string sqlind-report-runaway-string)
    (comment-continuation sqlind-indent-comment-continuation)
    (comment-start sqlind-indent-comment-start)
    (toplevel 0)
    (in-block +)
    (in-begin-block +)
    (block-start 0)
    (block-end 0)
    (declare-statement +)
    (package ++)
    (package-body 0)
    (create-statement +)
    (defun-start +)
    (labeled-statement-start 0)
    (statement-continuation +)
    (nested-statement-open sqlind-use-anchor-indentation +)
    (nested-statement-continuation sqlind-use-previous-line-indentation)
    (nested-statement-close sqlind-use-anchor-indentation)
    (with-clause sqlind-use-anchor-indentation)
    (with-clause-cte +)
    (with-clause-cte-cont ++)
    (case-clause 0)
    (case-clause-item sqlind-use-anchor-indentation +)
    (case-clause-item-cont sqlind-right-justify-clause)
    (select-clause 0)
    (select-column sqlind-indent-select-column)
    (select-column-continuation sqlind-indent-select-column +)
    (select-join-condition ++)
    (select-table sqlind-indent-select-table)
    (select-table-continuation sqlind-indent-select-table +)
    (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
    (insert-clause 0)
    (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
    (delete-clause 0)
    (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
    (update-clause 0)
    (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

(defun renz/sql-indentation-offsets ()
  (setq sqlind-indentation-offsets-alist
        renz/sql-indentation-offsets-alist)
  (setq sqlind-basic-offset 4))

(use-package sql-indent
  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

(use-package sql-mode
  :hook ((sql-mode . renz/sql-mode-hook)
         (sql-mode . sqlup-mode)
         (sql-mode . sqlind-minor-mode)))
;; Indentation:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.][Interactive ~hive2~ mode:1]]
(use-package hive2
  :load-path "site-lisp/"
  :demand t
  :mode ("\\.hql" . sql-mode))
;; Interactive ~hive2~ mode:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.][Interactive =bq shell=:3]]
(use-package bq
  :load-path "site-lisp"
  :demand t)
;; Interactive =bq shell=:3 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.][BigQuery ~sql~ Blocks in Org-Babel:1]]
(defun org-babel-execute:bq (orig-fun body params)
  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
      (json-to-org-table-parse-json-string
       (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
                                params))
    (org-babel-execute:sql body params)))

(advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; BigQuery ~sql~ Blocks in Org-Babel:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python][Python:1]]
(add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; Python:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.][Flatten items in =imenu=:1]]
(add-hook 'python-mode-hook
          (lambda () (setq-local imenu-create-index-function
                                 'python-imenu-create-flat-index)))

(add-hook 'python-ts-mode-hook
          (lambda () (setq-local imenu-create-index-function
                                 'python-imenu-treesit-create-flat-index)))
;; Flatten items in =imenu=:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.][Respect =python-shell-virtualenv-root= when using =python-check=:1]]
(defun renz/python-add-path-to-process-environment (res)
  (when-let* ((virtualenv (when python-shell-virtualenv-root
                            (directory-file-name python-shell-virtualenv-root)))
              (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
    (push (format "PATH=%s" (mapconcat
                             #'identity
                             (reverse
                              (cons (getenv "PATH")
                                    (list bin-dir)))
                             ":")) res) res))

(advice-add 'python-shell--calculate-process-environment
            :filter-return
            #'renz/python-add-path-to-process-environment)
;; Respect =python-shell-virtualenv-root= when using =python-check=:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=][Interactively setting the virtual environment for =pyrightconfig.json=:1]]
(defun pyrightconfig-write (virtualenv)
  "Write a `pyrightconfig.json' file at the Git root of a project
with `venvPath' and `venv' set to the absolute path of
`virtualenv'.  When run interactively, prompts for a directory to
select."
  (interactive "DEnv: ")
  ;; Naming convention for venvPath matches the field for pyrightconfig.json
  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
         (venv-file-name (directory-file-name venv-dir))
         (venvPath (file-name-directory venv-file-name))
         (venv (file-name-base venv-file-name))
         (base-dir (vc-git-root default-directory))
         (out-file (expand-file-name "pyrightconfig.json" base-dir))
         (out-contents (json-encode (list :venvPath venvPath :venv venv))))
    (with-temp-file out-file (insert out-contents))
    (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; Interactively setting the virtual environment for =pyrightconfig.json=:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.][Pyright error links in =*compilation*=:1]]
(with-eval-after-load 'compile
  (add-to-list 'compilation-error-regexp-alist-alist
               '(pyright "^[[:blank:]]+\\(.+\\):\\([0-9]+\\):\\([0-9]+\\).*$" 1 2 3))
  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; Pyright error links in =*compilation*=:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.][Python check with "ruff":1]]
(use-package python
  :config
  (require 'eglot)
  (setq python-check-command "ruff")
  (add-hook 'python-mode-hook #'flymake-mode)
  (add-hook 'python-ts-mode-hook #'flymake-mode)
  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
  )
;; Python check with "ruff":1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.][Make check command and virtualenv root safe for .dir-locals.el:2]]
(put 'python-check-command 'safe-local-variable #'stringp)
(put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
(put 'python-interpreter 'safe-local-variable #'stringp)
;; Make check command and virtualenv root safe for .dir-locals.el:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.][pyrightconfig.json:1]]
(use-package pyrightconfig
  :after (python))
;; pyrightconfig.json:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.][Markdown:1]]
(when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
  (setq markdown-command "markdown_py"))
;; Markdown:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.

;; #+begin_src emacs-lisp
;;  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
;;  (setq markdown-command "markdown_py"))
;; #+end_src

;; Some folks like to write markdown without hard line breaks. When viewing those
;; documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
;; it.][Markdown:2]]
(defun renz/md-hook ()
  "View buffer in visual fill mode with 80 character width."
  (interactive)
  (visual-fill-column-mode)
  (setq-local fill-column 80))
;; Markdown:2 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.

;; #+begin_src emacs-lisp
;;  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
;;  (setq markdown-command "markdown_py"))
;; #+end_src

;; Some folks like to write markdown without hard line breaks. When viewing those
;; documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
;; it.

;; #+begin_src emacs-lisp
;;  (defun renz/md-hook ()
;;  "View buffer in visual fill mode with 80 character width."
;;  (interactive)
;;  (visual-fill-column-mode)
;;  (setq-local fill-column 80))
;; #+end_src

;; I make a lot of spelling mistakes as I type...][Markdown:3]]
(add-hook 'markdown-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'auto-fill-mode)
;; Markdown:3 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.

;; #+begin_src emacs-lisp
;;  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
;;  (setq markdown-command "markdown_py"))
;; #+end_src

;; Some folks like to write markdown without hard line breaks. When viewing those
;; documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
;; it.

;; #+begin_src emacs-lisp
;;  (defun renz/md-hook ()
;;  "View buffer in visual fill mode with 80 character width."
;;  (interactive)
;;  (visual-fill-column-mode)
;;  (setq-local fill-column 80))
;; #+end_src

;; I make a lot of spelling mistakes as I type...

;; #+begin_src emacs-lisp
;;  (add-hook 'markdown-mode-hook 'flyspell-mode)
;;  (add-hook 'markdown-mode-hook 'auto-fill-mode)
;; #+end_src

;; And I like to see language syntax highlighting within code fences.][Markdown:4]]
(setq markdown-fontify-code-blocks-natively t)
;; Markdown:4 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.

;; #+begin_src emacs-lisp
;;  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
;;  (setq markdown-command "markdown_py"))
;; #+end_src

;; Some folks like to write markdown without hard line breaks. When viewing those
;; documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
;; it.

;; #+begin_src emacs-lisp
;;  (defun renz/md-hook ()
;;  "View buffer in visual fill mode with 80 character width."
;;  (interactive)
;;  (visual-fill-column-mode)
;;  (setq-local fill-column 80))
;; #+end_src

;; I make a lot of spelling mistakes as I type...

;; #+begin_src emacs-lisp
;;  (add-hook 'markdown-mode-hook 'flyspell-mode)
;;  (add-hook 'markdown-mode-hook 'auto-fill-mode)
;; #+end_src

;; And I like to see language syntax highlighting within code fences.

;; #+begin_src emacs-lisp
;;  (setq markdown-fontify-code-blocks-natively t)
;; #+end_src

;; ** csv-mode
;; Handy for viewing data quickly.][csv-mode:1]]
(use-package csv-mode
  :mode "\\.csv\\'")
;; csv-mode:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.

;; #+begin_src emacs-lisp
;;  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
;;  (setq markdown-command "markdown_py"))
;; #+end_src

;; Some folks like to write markdown without hard line breaks. When viewing those
;; documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
;; it.

;; #+begin_src emacs-lisp
;;  (defun renz/md-hook ()
;;  "View buffer in visual fill mode with 80 character width."
;;  (interactive)
;;  (visual-fill-column-mode)
;;  (setq-local fill-column 80))
;; #+end_src

;; I make a lot of spelling mistakes as I type...

;; #+begin_src emacs-lisp
;;  (add-hook 'markdown-mode-hook 'flyspell-mode)
;;  (add-hook 'markdown-mode-hook 'auto-fill-mode)
;; #+end_src

;; And I like to see language syntax highlighting within code fences.

;; #+begin_src emacs-lisp
;;  (setq markdown-fontify-code-blocks-natively t)
;; #+end_src

;; ** csv-mode
;; Handy for viewing data quickly.

;; #+begin_src emacs-lisp
;;  (use-package csv-mode
;;  :mode "/.csv/'")
;; #+end_src

;; * Tool configuration
;; These are tweaks for third party packages.

;; ** Visual fill column
;; For visual lines, this adds line breaks at the fill-column value. Especially
;; useful for prose that is meant to be copied to other mediums, such as email or
;; word.][Visual fill column:1]]
(use-package visual-fill-column
  :config
  (add-hook 'visual-line-mode-hook #'visual-fill-column-mode))
;; Visual fill column:1 ends here

;; [[file:README.org::(use-package hippie-exp
;;  :config
;;  (global-set-key /[remap dabbrev-expand/] 'hippie-expand)
;;  (delete 'try-expand-line hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol-partially hippie-expand-try-functions-list)
;;  (delete 'try-complete-lisp-symbol hippie-expand-try-functions-list))
;; #+end_src

;; ** ~dired~
;; By default, ~dired~ uses bytes instead of "K", "Mb", or "G" for file sizes. I
;; also have it hide the mode, size, and owner of each file by default.

;; #+begin_src emacs-lisp
;;  (use-package dired
;;  :hook (dired-mode . dired-hide-details-mode)
;;  :config
;;  (setq dired-listing-switches "-alFh")
;;  (setq dired-dwim-target t))
;; #+end_src

;; Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired
;; windows are open, and we want to copy something from one location to the other.
;; By enabling ~dired-dwim-target~, it auto-populates the minibuffer with the other
;; dired window's path when issuing a copy command with ~C~.

;; ** eww - search engine and browser

;; Ecosia requires JavaScript, unfortunately.

;; #+begin_src emacs-lisp
;;  (use-package eww
;;  :config (setq eww-search-prefix "https:/duckduckgo.com/html/?q="))
;; #+end_src

;; ** Language Server Protocol (LSP) with ~eglot~
;; As of version 29, /[/[https:/github.com/joaotavora/eglot/]/[eglot/]/] (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the
;; client side configuration for the /[/[https:/microsoft.github.io/language-server-protocol/]/[language server protocol/]/].

;; #+begin_src emacs-lisp
;;  (use-package eglot
;;  :bind (("C-c l c" . eglot-reconnect)
;;  ("C-c l d" . flymake-show-buffer-diagnostics)
;;  ("C-c l f f" . eglot-format)
;;  ("C-c l f b" . eglot-format-buffer)
;;  ("C-c l l" . eglot)
;;  ("C-c l r n" . eglot-rename)
;;  ("C-c l s" . eglot-shutdown)))
;; #+end_src

;; To have ~eglot~ always start up for a python buffer, we would tangle this line
;; into ~init.el~. However, this can cause a significant loading delay over Tramp,
;; and I would prefer snappy, simple access with LSP provided on an as-needed
;; basis.

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'eglot-ensure)
;; #+end_src

;; *** Side show: ~semantic-mode~
;; For a while, it looks like Emacs was trying out something called /[/[https:/www.gnu.org/software/emacs/manual/html_node/semantic/Semantic-mode.html/]/[semantic-mode/]/],
;; which looks a lot like a precursor to what we now know as the /[/[https:/microsoft.github.io/language-server-protocol/]/[Language Server
;; Protocol/]/]. Enabling it was done through adding the ~semantic-mode~ hook to your
;; language's major mode hook:

;; #+begin_src emacs-lisp :tangle no :eval never
;;  (add-hook 'python-mode-hook 'semantic-mode)
;; #+end_src

;; ** Shell commands

;; The Async command buffer's default behavior is to print =^M= characters (the
;; carriage return) instead of actually clearing text. This is problematic for
;; spinners and progress bars, so I have a little hack to work around that.

;; #+begin_src emacs-lisp
;;  (defun renz/async-shell-command-filter-hook ()
;;  "Filter async shell command output via `comint-output-filter'."
;;  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
;;  ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
;;  ;; are displayed
;;  (setq-local comint-inhibit-carriage-motion nil)
;;  (when-let ((proc (get-buffer-process (current-buffer))))
;;  ;; Attempting a solution found here:
;;  ;; https:/gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output
;;  (set-process-filter proc 'comint-output-filter))))

;;  (add-hook 'shell-mode-hook #'renz/async-shell-command-filter-hook)
;; #+end_src

;; There might be a better way, but this mostly works for now.

;; ** Tramp
;; Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on
;; a remote machine, and edit them locally. This is great for simple changes or
;; quickly testing out some Python on a VM somewhere. It isn't as snappy as using
;; the TTY version or an X-forwarded Emacs from the server directly, so if I /can/
;; set up Emacs remotely, I usually do. When I don't want to or don't have the
;; time, Tramp is a godsend. There are, however, many foibles to guard against,
;; particularly with how interacts with version control and ~.dir-locals~. The
;; Tramp manual (distributed with Emacs) recommends adjusting these for some speed
;; improvements:

;; #+begin_src emacs-lisp
;;  (use-package tramp
;;  :defer t
;;  :config
;;  (setq vc-handled-backends '(Git)
;;  file-name-inhibit-locks t
;;  tramp-inline-compress-start-size 1000
;;  tramp-copy-size-limit 10000
;;  tramp-verbose 1)
;;  (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
;; #+end_src

;; For some time I was having a lot of trouble with prohibitive slowness over
;; Tramp, and after careful scrutiny of the logs on (I believe) =tramp-verbose 6=, I
;; found out that enabling remote dir-locals was causing a huge bottleneck. On
;; every operation it would trace up the filesystem tree back to the root
;; directory, scanning for a ~.dir-locals~ file. Since some of the drives were
;; network-mounted, this caused thousands of network calls per file operation,
;; obviously slowing things down a lot. Because of this, I've opted to simply
;; disable ~.dir-locals~ over Tramp entirely, since I don't really use it much, if at
;; all.

;; #+begin_src emacs-lisp :tangle no :eval never
;; ;; (setq enable-remote-dir-locals t)
;; #+end_src

;; /[/[https:/www.gnu.org/software/emacs/manual/html_node/tramp/Frequently-Asked-Questions.html/]/[Disabling VC/]/] /does/ seem to speed things up a little, but it's not an acceptable
;; thing to put in, since I so frequently use VC over tramp. Fully disabling VC
;; would include this snippet:

;; #+begin_src emacs-lisp :tangle no :eval never
;; (remove-hook 'find-file-hook 'vc-find-file-hook)

;; (setq vc-ignore-dir-regexp
;;  (format "/(%s/)/|/(%s/)"
;;  vc-ignore-dir-regexp
;;  tramp-file-name-regexp))
;; #+end_src

;; Additionally, these came up as other potential options /[/[https:/github.com/doomemacs/doomemacs/issues/3909/]/[from the doom-emacs
;; issues/]/], which I do not currently include.

;; #+begin_src emacs-lisp :tangle no :eval never
;; (setq tramp-default-method "scp")
;; (setq projectile--mode-line "Projectile")
;; #+end_src

;; I often need to set these in ~/.ssh/config for TRAMP to speed up

;; #+begin_example
;; Host *
;;  ControlMaster auto
;;  ControlPath ~/.ssh/master-%h:%p
;;  ControlPersist 10m
;;  ForwardAgent yes
;;  ServerAliveInterval 60
;; #+end_example

;; * Keybindings

;; ** Expanded/better defaults

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-M-<backspace>") 'backward-kill-sexp)
;; #+end_src

;; The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on
;; the GUI was frustrating as hell, so now I use =C-x C-z= if I /really/ want to
;; suspend the frame.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-z") #'zap-up-to-char)
;; #+end_src

;; ~ibuffer~ is a strictly superior, built-in version of its counterpart.

;; #+begin_src emacs-lisp
;;  (global-set-key /[remap list-buffers/] 'ibuffer)
;; #+end_src

;; The most common situation where I'm running ~flymake~ would be for spelling in
;; prose, or diagnostics from a language server. In either case, I like having
;; next/previous on easy to reach chords.

;; #+begin_src emacs-lisp
;;  (use-package flymake
;;  :bind (:map flymake-mode-map
;;  ("C-c n" . flymake-goto-next-error)
;;  ("C-c p" . flymake-goto-prev-error)))
;; #+end_src

;; ** Overriding defaults
;; Some default bindings aren't useful for me, so I bind them to actions I take
;; more frequently.

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-x C-p") 'previous-buffer) ; Overrides `mark-page'
;;  (global-set-key (kbd "C-x C-n") 'next-buffer) ; Overrides `set-goal-column'
;; #+end_src

;; ** C-c bindings
;; Emacs has /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Key-Bindings.html/]/[some standards/]/] about where user-configured keys should go; =C-c
;; <letter>= is always free for users. It may seem like overkill how I set a header
;; for each possible =C-c= combination, but it's incredibly handy when I want to jump
;; directly to one of these headings while in another buffer. See e.g. =org-goto=,
;; which allows me to narrow in on a particular key I'd like to bind by leveraging
;; =completing-read=. If a =C-c <letter>= combination is missing as a header, then I'm
;; probably using it in a ~:bind~ statement with ~use-package~ somewhere else.

;; *** =C-c b= build / compile

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c b") #'compile)
;;  (global-set-key (kbd "C-c B") #'recompile)
;; #+end_src

;; *** =C-c c= Insert current dir/file at point

;; #+begin_src emacs-lisp
;;  (defun renz/insert-current-dir ()
;;  "Insert the current `default-directory' at point."
;;  (interactive)
;;  (insert default-directory))

;;  (defun renz/insert-current-file ()
;;  "Insert the current buffer's full file name at point."
;;  (interactive)
;;  ;; https:/unix.stackexchange.com/a/45381
;;  (insert (buffer-file-name (window-buffer (minibuffer-selected-window)))))

;;  (global-set-key (kbd "C-c c d") #'renz/insert-current-dir)
;;  (global-set-key (kbd "C-c c f") #'renz/insert-current-file)
;; #+end_src

;; *** =C-c d= Navigating to symbols using old-school TAGS

;; Before the whole language server revolution, we had TAGS files for caching the
;; location of symbol definitions. =etags= comes with Emacs, and combining some
;; clever use of =find= with it can render a pretty good symbol search experience.
;; To generate the TAGS file, I usually have a =TAGS= recipe that looks something
;; similar to this in each project's =Makefile=:

;; #+begin_src shell
;;  find . -type d -name ".venv" -prune /
;;  -o -type d -name ".ipynb_checkpoints" -prune /
;;  -o -type d -name ".node_modules" -prune /
;;  -o -type d -name "elpa" -prune /
;;  -o -type f -name "*.py" -print /
;;  -o -type f -name "*.sql" -print /
;;  -o -type f -name "*.el" -print /
;;  | etags -
;; #+end_src

;; Then, =M-x project-compile RET make TAGS= builds a tags table. At which point, I
;; can use =tags-completion-table= to build a list of symbols I can navigate to with
;; completion, with just a little help from =xref-find-definitions=.

;; #+begin_src emacs-lisp
;;  (defun renz/find-tag ()
;;  "Use `completing-read' to navigate to a tag."
;;  (interactive)
;;  (require 'etags)
;;  (tags-completion-table)
;;  (xref-find-definitions (completing-read "Find tag: " tags-completion-table)))

;;  (global-set-key (kbd "C-c d") #'renz/find-tag)
;; #+end_src

;; *** =C-c f= find file at point (ffap)

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c f") #'ffap)
;; #+end_src

;; *** =C-c i= browse url of buffer

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c i") #'browse-url-of-buffer)
;; #+end_src

;; *** =C-c j= Toggle window split
;; /[/[https:/www.emacswiki.org/emacs/ToggleWindowSplit/]/[Toggling windows/]/] from vertical to horizontal splits and vice-versa.

;; #+begin_src emacs-lisp
;;  (defun toggle-window-split ()
;;  "Switch between horizontal and vertical split window layout."
;;  (interactive)
;;  (if (= (count-windows) 2)
;;  (let* ((this-win-buffer (window-buffer))
;;  (next-win-buffer (window-buffer (next-window)))
;;  (this-win-edges (window-edges (selected-window)))
;;  (next-win-edges (window-edges (next-window)))
;;  (this-win-2nd (not (and (<= (car this-win-edges)
;;  (car next-win-edges))
;;  (<= (cadr this-win-edges)
;;  (cadr next-win-edges)))))
;;  (splitter
;;  (if (= (car this-win-edges)
;;  (car (window-edges (next-window))))
;;  'split-window-horizontally
;;  'split-window-vertically)))
;;  (delete-other-windows)
;;  (let ((first-win (selected-window)))
;;  (funcall splitter)
;;  (if this-win-2nd (other-window 1))
;;  (set-window-buffer (selected-window) this-win-buffer)
;;  (set-window-buffer (next-window) next-win-buffer)
;;  (select-window first-win)
;;  (if this-win-2nd (other-window 1))))))

;;  (global-set-key (kbd "C-c j") #'toggle-window-split)
;; #+end_src

;; *** =C-c k= kill all but one space

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c k") #'just-one-space)
;; #+end_src

;; *** =C-c q= replace regexp

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c q") #'replace-regexp)
;; #+end_src

;; *** =C-c r= find recent files

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c r") #'renz/find-recent-file)
;; #+end_src

;; *** =C-c s= shell

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c s s") #'shell)
;;  (global-set-key (kbd "C-c s e") #'eshell)
;;  (global-set-key (kbd "C-c s t") #'term)
;; #+end_src

;; *** =C-c u= open URL at point in browser

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c u") #'browse-url-at-point)
;; #+end_src

;; *** =C-c v= faster git-commit

;; #+begin_src emacs-lisp
;;  (defun renz/git-commit ()
;;  (interactive)
;;  (vc-next-action nil)
;;  (log-edit-show-diff)
;;  (other-window 1))

;;  (global-set-key (kbd "C-c v") #'renz/git-commit)
;; #+end_src

;; *** =C-c w= whitespace mode

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c w") #'whitespace-mode)
;; #+end_src

;; *** =C-c x= misc. "execute" commands

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c x r") #'restart-emacs)
;; #+end_src

;; *** =C-c= Other bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "C-c <DEL>") #'backward-kill-sexp) ;; TTY-frindly
;;  (global-set-key (kbd "C-c <SPC>") #'mark-sexp) ;; TTY-friendly
;; #+end_src

;; ** F5-F9
;; Like the =C-c <letter>= bindings, these are reserved for users. In practice, even
;; though there are few of these keys, I tend to forget which is which. So I wind
;; up using things bound to my =C-c= keymaps instead. The =C-c= kyes from a more
;; natural, nested language in my head, so it feels more like I'm "speaking Emacs"
;; that way.

;; ** Super bindings

;; #+begin_src emacs-lisp
;;  (global-set-key (kbd "s-p") #'project-switch-project)
;; #+end_src

;; * Text Completion
;; Emacs offers incredible depth and freedom when configuring methods to
;; automatically complete text. There are actually two things that
;; "autocompletion" can refer to in Emacs:

;; 1. /[/[https:/www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html/]/[Minibuffer completion/]/]
;; 2. /[/[https:/www.gnu.org/software/emacs/manual/html_node/elisp/Completion-in-Buffers.html/]/[Completion at point/]/]

;; Emacs on its own does not have a nice pop-up-menu like Vim for completing text
;; at point. For both the minibuffer and ~completion-at-point~ it uses a special
;; buffer called ~*Completions*~, from which we can see (and optionally select) a
;; completion from potential candidates. Before we get to tweak those settings,
;; though, we first need to oil the engine with an enhanced /completion style/

;; ** Completion style
;; For both the minibuffer and ~completion-at-point~, I use the same /completion
;; style/. Completion style is the method of assigning completion candidates to a
;; given input string. ~flex~ is the built-in "fuzzy" completion style, familiar to
;; us from symbol completion in IDEs and VSCode's command palette. ~basic~ functions
;; much like your default TAB-complete at a Bash shell.

;; #+begin_src emacs-lisp
;;  (setq completion-styles '(flex basic partial-completion emacs22))
;; #+end_src

;; ** Nicer Display and Behavior of ~*Completions*~
;; With the /completion style/ set, we now have to configure the interface for
;; /displaying/ candidates as we type. First, I want candidates displayed as a
;; single, vertical list.

;; #+begin_src emacs-lisp
;;  (setq completions-format 'one-column)
;; #+end_src

;; Also, when using the built-in completion-at-point, the ~*Completions*~ buffer can
;; sometimes take up the whole screen when there are a lot of candidates.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completions-max-height 15))
;; #+end_src

;; Some time ago, Prot wrote a package called /[/[https:/github.com/protesilaos/mct/blob/main/mct.el/]/[MCT/]/] (Minibuffer and Completions in
;; Tandem) that enhanced the default minibuffer and ~*Completions*~ buffer behavior
;; to act more like what we expect of a modern editor's auto-complete. He
;; discontinued development of that project once it became clear that Emacs 29 was
;; going to include similar behavior as a configurable option. These are the
;; options in question.

;; #+begin_src emacs-lisp
;;  (unless (version< emacs-version "29.0")
;;  (setq completion-auto-help 'always
;;  completion-auto-select 'second-tab
;;  completion-show-help nil
;;  completions-sort nil
;;  completions-header-format nil))
;; #+end_src

;; ** Completion in the minibuffer and at point
;; By default, Emacs uses =M-TAB=, or the equivalent =C-M-i= for ~completion-at-point~.
;; I'd much prefer to use the easier and more intuitive =TAB=.

;; #+begin_src emacs-lisp
;;  (setq tab-always-indent 'complete)
;; #+end_src

;; Something I might try is to use =icomplete= along with =icomplete-in-buffer= to get
;; something like a little window that updates as I type. It seems a little wonky,
;; since TAB-completion will still cause the /ast{}Completions/ast{} buffer to pop up, even
;; while Icomplete is active, unless we set =completion-auto-help= to =lazy=; and even
;; then it will still come up on the second TAB press.

;; #+begin_src emacs-lisp :tangle no
;;  (setq icomplete-in-buffer t)
;;  (setq icomplete-prospects-height 10)
;;  (icomplete-vertical-mode t)
;; #+end_src

;; In the case that we need to enter a new file name, but =fido= is still showing a
;; completion candidate, you have to use =C-d= to refuse completion and take whatever
;; is currently in the prompt. For instance, if we are editing a file =hello.py=,
;; and then use =C-x C-f hell.py=, the minibuffer will complete =hell.py= into =hello.py=
;; if we use =RET=, and will open a new buffer for =hell.py= if we use =C-d=.

;; * Language-specific major modes
;; ** Shell (Bash, sh, ...)
;; #+begin_src emacs-lisp
;;  (defun renz/sh-indentation ()
;;  ;; (setq indent-tabs-mode t)
;;  (setq tab-width 8))

;;  (add-hook 'sh-mode-hook #'renz/sh-indentation)
;;  (add-hook 'bash-ts-mode-hook #'renz/sh-indentation)
;; #+end_src

;; ** HTML

;; This changes the behavior of a few commonly-used tags in web pages that I write.

;; #+begin_src emacs-lisp
;;  (use-package sgml-mode
;;  :defer t
;;  :config
;;  (let* ((p-tag-old (assoc "p" html-tag-alist))
;;  ;; Close the <p> tag and open on a new line.
;;  (p-tag-new `("p" /n ,(cdr (cdr p-tag-old)))))
;;  (add-to-list 'html-tag-alist p-tag-new)
;;  ;; Close the <code> tag and stay inline.
;;  (add-to-list 'html-tag-alist '("code"))))

;; #+end_src

;; ** CSS

;; #+begin_src emacs-lisp
;;  (setq css-indent-offset 2)
;; #+end_src

;; For validation, grab /[/[https:/github.com/w3c/css-validator/releases/download/cssval-20220105/css-validator.jar/]/[css-validator.jar/]/] and execute it with java:

;; #+begin_example
;;  java -jar ~/.local/jars/css-validator.jar file:/home/me/my/site/index.html
;; #+end_example

;; ** Org-mode

;; #+begin_src emacs-lisp
;;  (setq renz/org-home "~/.emacs.d/org/")
;; #+end_src

;; ~org-mode~ provides =org-babel-tangle-jump-to-org=, which jumps back to an Org
;; source file from within the tangled code. ~renz/org-babel-tangle-jump-to-src~,
;; defined below, does the opposite - given the Org source file and point inside a
;; ~src~ block, it jumps to the location of the tangled code. Provided by a helpful
;; /[/[https:/emacs.stackexchange.com/a/69591/]/[stackoverflow answer./]/]

;; #+begin_src emacs-lisp
;;  (defun renz/org-babel-tangle-jump-to-src ()
;;  "The opposite of `org-babel-tangle-jump-to-org'.
;;  Jumps to an Org src block from tangled code."
;;  (interactive)
;;  (if (org-in-block-p)
;;  (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
;;  (tangle (car header))
;;  (lang (caadr header))
;;  (buffer (nth 2 (cadr header)))
;;  (org-id (nth 3 (cadr header)))
;;  (source-name (nth 4 (cadr header)))
;;  (search-comment (org-fill-template
;;  org-babel-tangle-comment-format-beg
;;  `(("link" . ,org-id) ("source-name" . ,source-name))))
;;  (file (expand-file-name
;;  (org-babel-effective-tangled-filename buffer lang tangle))))
;;  (if (not (file-exists-p file))
;;  (message "File does not exist. 'org-babel-tangle' first to create file.")
;;  (find-file file)
;;  (beginning-of-buffer)
;;  (search-forward search-comment)))
;;  (message "Cannot jump to tangled file because point is not at org src block.")))
;; #+end_src

;; Now we configure ~org-mode~ itself. For a while I was trying =(setq
;; org-startup-indented t)= to get indentation under each header, but this was
;; interfering with the beautification features from ~org-modern~. Preferring the
;; latter over the former, I've removed the =org-startup-indented= call.

;; #+begin_src emacs-lisp
;;  (defun renz/list-files-with-absolute-path (directory)
;;  "Return a list of files in DIRECTORY with their absolute paths."
;;  (cl-remove-if-not #'file-regular-p (directory-files directory t ".*/.org$")))

;;  (use-package org
;;  :hook
;;  ((org-mode . (lambda () (progn
;;  (add-hook 'after-save-hook #'org-babel-tangle :append :local)
;;  (add-hook 'org-babel-after-execute-hook #'renz/display-ansi-colors)
;;  (setq indent-tabs-mode nil)))))

;;  :init
;;  (defun renz/jump-org ()
;;  "Prompt for an org file in my emacs directory, then go there."
;;  (interactive)
;;  (renz/--jump-section renz/org-home "Org files: " ".*/.org$"))

;;  :bind
;;  (("C-c o a" . org-agenda)
;;  ("C-c o b d" . org-babel-detangle)
;;  ("C-c o b o" . org-babel-tangle-jump-to-org)
;;  ("C-c o b s" . renz/org-babel-tangle-jump-to-src)
;;  ("C-c o k" . org-babel-remove-result)
;;  ("C-c o o" . renz/jump-org)
;;  ("C-c o y" . ox-clip-image-to-clipboard))

;;  :custom
;;  (org-image-actual-width nil "Enable resizing of images")
;;  (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) "Sources for Org agenda view")
;;  (org-html-htmlize-output-type nil "See C-h f org-html-htmlize-output-type")
;;  (org-confirm-babel-evaluate nil "Don't ask for confirmation when executing src blocks")
;;  (org-goto-interface 'outline-path-completion "Use completing-read for org-goto (C-c C-j, nicer than imenu)")
;;  (org-outline-path-complete-in-steps nil "Flatten the outline path, instead of completing hierarchically")

;;  :config
;;  (add-to-list 'org-modules 'org-tempo)
;;  (org-babel-do-load-languages
;;  'org-babel-load-languages
;;  '((emacs-lisp . t)
;;  (python . t)
;;  (sql . t)
;;  (shell . t)
;;  (R . t)
;;  ;; (fortran . t)
;;  ;; (julia . t)
;;  ;; (jupyter . t)
;;  ;; (scheme . t)
;;  ;; (haskell . t)
;;  (lisp . t)
;;  ;; (clojure . t)
;;  ;; (C . t)
;;  ;; (org . t)
;;  ;; (gnuplot . t)
;;  ;; (awk . t)
;;  ;; (latex . t)
;;  )))
;; #+end_src

;; ** SQL
;; *** DDL is SQL

;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("/.ddl/'" . sql-mode))
;;  (add-to-list 'auto-mode-alist '("/.bql/'" . sql-mode))
;; #+end_src

;; *** Indentation
;; Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code
;; pretty. I tend to format SQL like this:

;; #+begin_src sql :tangle no
;;  SELECT
;;  whatever,
;;  thing
;;  FROM
;;  wherever AS w
;;  JOIN the_other AS t ON w.id = t.id
;;  GROUP BY
;;  whatever
;; #+end_src

;; The configuration of =sql-indent= below achieves that nicely when using =RET= and
;; =TAB= for formatting.

;; #+begin_src emacs-lisp
;;  (defun renz/sql-mode-hook ()
;;  (setq tab-width 4))

;;  (defvar renz/sql-indentation-offsets-alist
;;  '((syntax-error sqlind-report-sytax-error)
;;  (in-string sqlind-report-runaway-string)
;;  (comment-continuation sqlind-indent-comment-continuation)
;;  (comment-start sqlind-indent-comment-start)
;;  (toplevel 0)
;;  (in-block +)
;;  (in-begin-block +)
;;  (block-start 0)
;;  (block-end 0)
;;  (declare-statement +)
;;  (package ++)
;;  (package-body 0)
;;  (create-statement +)
;;  (defun-start +)
;;  (labeled-statement-start 0)
;;  (statement-continuation +)
;;  (nested-statement-open sqlind-use-anchor-indentation +)
;;  (nested-statement-continuation sqlind-use-previous-line-indentation)
;;  (nested-statement-close sqlind-use-anchor-indentation)
;;  (with-clause sqlind-use-anchor-indentation)
;;  (with-clause-cte +)
;;  (with-clause-cte-cont ++)
;;  (case-clause 0)
;;  (case-clause-item sqlind-use-anchor-indentation +)
;;  (case-clause-item-cont sqlind-right-justify-clause)
;;  (select-clause 0)
;;  (select-column sqlind-indent-select-column)
;;  (select-column-continuation sqlind-indent-select-column +)
;;  (select-join-condition ++)
;;  (select-table sqlind-indent-select-table)
;;  (select-table-continuation sqlind-indent-select-table +)
;;  (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (insert-clause 0)
;;  (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (delete-clause 0)
;;  (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)
;;  (update-clause 0)
;;  (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))

;;  (defun renz/sql-indentation-offsets ()
;;  (setq sqlind-indentation-offsets-alist
;;  renz/sql-indentation-offsets-alist)
;;  (setq sqlind-basic-offset 4))

;;  (use-package sql-indent
;;  :hook (sqlind-minor-mode . renz/sql-indentation-offsets))

;;  (use-package sql-mode
;;  :hook ((sql-mode . renz/sql-mode-hook)
;;  (sql-mode . sqlup-mode)
;;  (sql-mode . sqlind-minor-mode)))
;; #+end_src

;; *** Interactive ~hive2~ mode
;; This "hive2" package came from the days where I was working on an on-prem system
;; that used ~hive2~ as the main command-line interface to Hive. I don't use this
;; much now, but it's a good reference for implementing a plug-in to a new
;; interactive SQL CLI.

;; #+begin_src emacs-lisp
;;  (use-package hive2
;;  :load-path "site-lisp/"
;;  :demand t
;;  :mode ("/.hql" . sql-mode))
;; #+end_src

;; *** Interactive =bq shell=
;; The SQL interactive commands are looking for a single executable file, so let's
;; set that up somewhere common, like =~/.local/bin/bq-shell=.

;; #+begin_src shell :tangle no
;;  #!/usr/bin/env sh
;;  bq shell "$@"
;; #+end_src

;; Also, we don't want to use "legacy SQL" in our queries, which requires us to
;; configure the ~bq query~ statically in a =~/.bigqueryrc= file, according to the
;; Google /[/[https:/issuetracker.google.com/issues/35905841/]/[issue tracker/]/].

;; #+begin_src :tangle ~/.bigqueryrc
;; /[query/]
;; --use_legacy_sql=false
;; #+end_src

;; Then enable the BQ product.

;; #+begin_src emacs-lisp
;;  (use-package bq
;;  :load-path "site-lisp"
;;  :demand t)
;; #+end_src

;; *** BigQuery ~sql~ Blocks in Org-Babel
;; #+OPTIONS: ^:nil
;; Advising ~org-babel-execute:sql~ in this way allows me to use ~#+begin_src sql
;; :engine bq :results raw~ blocks in org-babel and execute them with ~C-c C-c~. More
;; commonly, though, I set ~#+PROPERTY: header-args:sql :engine bq :results raw~ at
;; the top of the document so that I can just mark a ~src~ block as ~sql~ and be done
;; with it.

;; #+begin_src emacs-lisp
;;  (defun org-babel-execute:bq (orig-fun body params)
;;  (if (string-equal-ignore-case (cdr (assq :engine params)) "bq")
;;  (json-to-org-table-parse-json-string
;;  (org-babel-execute:shell (concat "bq query --format=json --nouse_legacy_sql '" body "'")
;;  params))
;;  (org-babel-execute:sql body params)))

;;  (advice-add 'org-babel-execute:sql :around #'org-babel-execute:bq)
;; #+end_src

;; This also typically requires =#+OPTIONS: ^:nil= at the top of the Org document to
;; stop underscores from messing up how column names are displayed.

;; *** TODO BigQuery exception markers
;; When running BigQuery from a =*compilation*= buffer, it would be nice if I could get
;; error markers to jump directly to the issue.

;; ** Python
;; #+begin_src emacs-lisp
;;  (add-to-list 'auto-mode-alist '("Pipfile" . toml-ts-mode))
;; #+end_src

;; *** Flatten items in =imenu=

;; The default behavior in large Python buffers is to nest symbols, so after using
;; =C-c C-j= (=imenu=), you first have to complete what /kind/ of symbol you're
;; looking for, such as a "Function", "Class", or "Variable", /then/ complete the
;; symbol itself. I'd much rather just search for the symbol to begin with, and by
;; using this flat index it will show me the symbol's type when I go to complete
;; it.

;; #+begin_src emacs-lisp
;;  (add-hook 'python-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-create-flat-index)))

;;  (add-hook 'python-ts-mode-hook
;;  (lambda () (setq-local imenu-create-index-function
;;  'python-imenu-treesit-create-flat-index)))
;; #+end_src

;; *** Respect =python-shell-virtualenv-root= when using =python-check=

;; Despite what the documentation in =python.el= says, it does not actually affect
;; your shell's =PATH= when running compilation through =python-check=. This chunk
;; remedies this possible mistake.

;; #+begin_src emacs-lisp
;;  (defun renz/python-add-path-to-process-environment (res)
;;  (when-let* ((virtualenv (when python-shell-virtualenv-root
;;  (directory-file-name python-shell-virtualenv-root)))
;;  (bin-dir (expand-file-name (if (eq system-type 'windows-nt) "Scripts" "bin") virtualenv)))
;;  (push (format "PATH=%s" (mapconcat
;;  #'identity
;;  (reverse
;;  (cons (getenv "PATH")
;;  (list bin-dir)))
;;  ":")) res) res))

;;  (advice-add 'python-shell--calculate-process-environment
;;  :filter-return
;;  #'renz/python-add-path-to-process-environment)
;; #+end_src

;; *** Interactively setting the virtual environment for =pyrightconfig.json=

;; #+begin_src emacs-lisp
;;  (defun pyrightconfig-write (virtualenv)
;;  "Write a `pyrightconfig.json' file at the Git root of a project
;;  with `venvPath' and `venv' set to the absolute path of
;;  `virtualenv'. When run interactively, prompts for a directory to
;;  select."
;;  (interactive "DEnv: ")
;;  ;; Naming convention for venvPath matches the field for pyrightconfig.json
;;  (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
;;  (venv-file-name (directory-file-name venv-dir))
;;  (venvPath (file-name-directory venv-file-name))
;;  (venv (file-name-base venv-file-name))
;;  (base-dir (vc-git-root default-directory))
;;  (out-file (expand-file-name "pyrightconfig.json" base-dir))
;;  (out-contents (json-encode (list :venvPath venvPath :venv venv))))
;;  (with-temp-file out-file (insert out-contents))
;;  (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
;; #+end_src

;; *** Pyright error links in =*compilation*=
;; The =M-x compile= feature does not recognize or parse ~pyright~ error messages out
;; of the box, so I add that support myself. Here's an example error message:

;; #+begin_example
;; /home/robb/tmp/errors.py/
;;  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
;;  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
;;  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal/[1/]"
;;  Operator "+" not supported for types "str" and "Literal/[1/]" (reportGeneralTypeIssues)
;; 2 errors, 1 warning, 0 informations
;; #+end_example

;; To get the basic =M-g M-n= and =M-g M-p= navigation working, we just need a regex to
;; parse file name, line, and column number.

;; #+begin_src emacs-lisp
;;  (with-eval-after-load 'compile
;;  (add-to-list 'compilation-error-regexp-alist-alist
;;  '(pyright "^/[/[:blank:/]/]+/(.+/):/(/[0-9/]+/):/(/[0-9/]+/).*$" 1 2 3))
;;  (add-to-list 'compilation-error-regexp-alist 'pyright))
;; #+end_src

;; It would be nice if we could also capture the =/(error/|warning/)= part as
;; "KIND", but I'm struggling to get it working.

;; *** Python check with "ruff"
;; Another nice vanilla feature of ~python-mode~ is =M-x python-check=, which runs a
;; pre-specified linter. Setting that to ~mypy~ or ~pyright~ if either of those
;; programs exist is a small time saver.

;; #+begin_src emacs-lisp
;;  (use-package python
;;  :config
;;  (require 'eglot)
;;  (setq python-check-command "ruff")
;;  (add-hook 'python-mode-hook #'flymake-mode)
;;  (add-hook 'python-ts-mode-hook #'flymake-mode)
;;  ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) "ruff-lsp"))
;;  )
;; #+end_src

;; *** Fix Microsoft Windows Issues
;; At one point, I ran into something similar to this /[/[https:/github.com/jorgenschaefer/elpy/issues/733/]/[elpy issue/]/] on Windows. The
;; culprit was "App Execution Aliases" with python and python3 redirecting to the
;; windows store. Using this fixed it:

;; #+begin_example
;;  winkey -> Manage app execution aliases -> uncheck python and python3
;; #+end_example

;; Also on Windows - a =pip install= of =pyreadline3= is required to make
;; tab-completion work at all. It provides the =readline= import symbol.

;; *** Make check command and virtualenv root safe for .dir-locals.el
;; Virtualenvs require ~.dir-locals.el~ to have something like:

;; #+begin_src emacs-lisp :tangle no :eval never
;; ((python-mode . ((python-shell-virtualenv-root . "/path/to/my/.venv"))))
;; #+end_src

;; However, this only operates on `run-python' shells. Also, for projects, we need to
;; make sure that setting the virtualenv root is marked as safe.

;; #+begin_src emacs-lisp
;;  (put 'python-check-command 'safe-local-variable #'stringp)
;;  (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp)
;;  (put 'python-interpreter 'safe-local-variable #'stringp)
;; #+end_src

;; *** Emacs Jupyter?
;; Eventually, I would like to try the /[/[https:/github.com/dzop/emacs-jupyter/]/[emacs-jupyter/]/] package to interface with
;; Jupyter kernels from org-mode.

;; *** pyrightconfig.json

;; The most consistent way to get =eglot= to properly configure the python virtual
;; environment with =pyright= is to have a static file at the root of the project,
;; called ~pyrightconfig.json~. I wrote a short plugin that allows me to select a
;; directory using =completing-read= and have Emacs write the content of
;; ~pyrightconfig.json~ based on what I selected, in the appropriate directory.

;; #+begin_src emacs-lisp
;;  (use-package pyrightconfig
;;  :after (python))
;; #+end_src

;; Configuring pyright this way rather than "activating" an environment through
;; Emacs (ala =pythonic-activate= or similar) means we can be running the language
;; server in more than one project at a time, each pointing to its respective
;; virtual environment.

;; ** Markdown
;; When installing =markdown= through Anaconda, the executable is actually called
;; =markdown_py=. In case =markdown= isn't found, use that instead.

;; #+begin_src emacs-lisp
;;  (when (and (not (executable-find "markdown")) (executable-find "markdown_py"))
;;  (setq markdown-command "markdown_py"))
;; #+end_src

;; Some folks like to write markdown without hard line breaks. When viewing those
;; documents, I can use ~M-x renz/md-hook~ to view it as if there were line breaks in
;; it.

;; #+begin_src emacs-lisp
;;  (defun renz/md-hook ()
;;  "View buffer in visual fill mode with 80 character width."
;;  (interactive)
;;  (visual-fill-column-mode)
;;  (setq-local fill-column 80))
;; #+end_src

;; I make a lot of spelling mistakes as I type...

;; #+begin_src emacs-lisp
;;  (add-hook 'markdown-mode-hook 'flyspell-mode)
;;  (add-hook 'markdown-mode-hook 'auto-fill-mode)
;; #+end_src

;; And I like to see language syntax highlighting within code fences.

;; #+begin_src emacs-lisp
;;  (setq markdown-fontify-code-blocks-natively t)
;; #+end_src

;; ** csv-mode
;; Handy for viewing data quickly.

;; #+begin_src emacs-lisp
;;  (use-package csv-mode
;;  :mode "/.csv/'")
;; #+end_src

;; * Tool configuration
;; These are tweaks for third party packages.

;; ** Visual fill column
;; For visual lines, this adds line breaks at the fill-column value. Especially
;; useful for prose that is meant to be copied to other mediums, such as email or
;; word.

;; #+begin_src emacs-lisp
;;  (use-package visual-fill-column
;;  :config
;;  (add-hook 'visual-line-mode-hook #'visual-fill-column-mode))
;; #+end_src

;; ** Automatically Using TreeSitter Modes
;; I've posted this to GitHub and MELPA as /[/[https:/github.com/renzmann/treesit-auto/]/[treesit-auto/]/].][Automatically Using TreeSitter Modes:1]]
(use-package treesit-auto
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist)
  (global-treesit-auto-mode))
;; Automatically Using TreeSitter Modes:1 ends here

(provide 'init.el)
;;; init.el ends here
